<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s Blog</title>
  
  <subtitle>丁昌乾_技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jasondcq.github.io/"/>
  <updated>2020-05-24T14:45:23.489Z</updated>
  <id>https://jasondcq.github.io/</id>
  
  <author>
    <name>JasonD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础之类与对象、封装、构造方法</title>
    <link href="https://jasondcq.github.io/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>https://jasondcq.github.io/Java%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-24T14:34:00.000Z</published>
    <updated>2020-05-24T14:45:23.489Z</updated>
    
    <content type="html"><![CDATA[<h4 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义类：就是定义类的成员，包括成员变量和成员方法。</li><li>成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。</li><li>成员方法：和以前定义方法几乎是一样的。</li></ul><p>类的定义格式举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  String name；<span class="comment">//姓名</span></span><br><span class="line">  <span class="keyword">int</span> age；<span class="comment">//年龄</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//成员方法</span></span><br><span class="line">  <span class="comment">//学习的方法</span></span><br><span class="line">  <span class="function">publicvoid <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"好好学习，天天向上"</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//吃饭的方法</span></span><br><span class="line">  <span class="function">publicvoid <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"学习饿了要吃饭"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h4><p>创建对象：<code>类名 对象名 = new 类名();</code><br>使用对象访问类中的成员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.成员变量；</span><br><span class="line">对象名.成员方法()；</span><br></pre></td></tr></table></figure><p>对象的使用格式举例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01_Student</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建对象格式：类名 对象名 = new 类名();</span></span><br><span class="line">    Student s = <span class="keyword">new</span> Student();</span><br><span class="line">    System.out.println(<span class="string">"s:"</span>+s); </span><br><span class="line">    <span class="comment">//直接输出成员变量值</span></span><br><span class="line">    System.out.println(<span class="string">"姓名："</span>+s.name); <span class="comment">//null</span></span><br><span class="line">    System.out.println(<span class="string">"年龄："</span>+s.age); <span class="comment">//0</span></span><br><span class="line">    System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">    <span class="comment">//给成员变量赋值</span></span><br><span class="line">    s.name = <span class="string">"赵丽颖"</span>;</span><br><span class="line">    s.age = <span class="number">18</span>;</span><br><span class="line">    <span class="comment">//再次输出成员变量的值</span></span><br><span class="line">    System.out.println(<span class="string">"姓名："</span>+s.name); <span class="comment">//赵丽颖</span></span><br><span class="line">    System.out.println(<span class="string">"年龄："</span>+s.age); <span class="comment">//18</span></span><br><span class="line">    System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">    <span class="comment">//调用成员方法</span></span><br><span class="line">    s.study(); <span class="comment">// "好好学习，天天向上"</span></span><br><span class="line">    s.eat(); <span class="comment">// "学习饿了要吃饭"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="封装的步骤"><a href="#封装的步骤" class="headerlink" title="封装的步骤"></a>封装的步骤</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;类的定义格式&quot;&gt;&lt;a href=&quot;#类的定义格式&quot; class=&quot;headerlink&quot; title=&quot;类的定义格式&quot;&gt;&lt;/a&gt;类的定义格式&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
    
      <category term="java" scheme="https://jasondcq.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jasondcq.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之数组</title>
    <link href="https://jasondcq.github.io/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>https://jasondcq.github.io/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/</id>
    <published>2020-05-24T14:03:00.000Z</published>
    <updated>2020-05-24T14:26:30.269Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h4><ul><li>数组概念： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致</li></ul><h4 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h4><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p>格式：<code>数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度];</code><br>数组定义格式详解：</p><ul><li>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。</li><li>[] : 表示数组。</li><li>数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。</li><li>new：关键字，创建数组使用的关键字。</li><li>数组存储的数据类型：创建的数组容器可以存储什么数据类型。</li><li>[长度]：数组的长度，表示数组容器中可以存储多少个元素。<br>注意：数组有定长特性，长度一旦指定，不可更改。</li></ul><p>定义可以存储3个整数的数组容器，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>格式：<code>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,元素3...};</code><br>定义存储1，2，3，4，5整数的数组容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h5 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h5><p>格式：<code>数据类型[] 数组名 = {元素1,元素2,元素3...};</code><br>定义存储1，2，3，4，5整数的数组容器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h4><p>索引：每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素</p><p>格式：<code>数组名[索引]</code></p><p>数组的长度属性： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度，语句为：<code>数组名.length</code> ，属性length的执行结果是数组的长度，int类型结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="comment">//打印数组的属性，输出结果是5</span></span><br><span class="line">  System.out.println(arr.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引访问数组中的元素：</p><ul><li>数组名[索引]=数值，为数组中的元素赋值</li><li>变量=数组名[索引]，获取出数组中的元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义存储int类型数组，赋值元素1，2，3，4，5</span></span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  <span class="comment">//为0索引元素赋值为6</span></span><br><span class="line">  arr[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">  <span class="comment">//获取数组0索引上的元素</span></span><br><span class="line">  <span class="keyword">int</span> i = arr[<span class="number">0</span>];</span><br><span class="line">  System.out.println(i);</span><br><span class="line">  <span class="comment">//直接输出数组0索引元素</span></span><br><span class="line">  System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="数组作为方法参数"><a href="#数组作为方法参数" class="headerlink" title="数组作为方法参数"></a>数组作为方法参数</h4><ul><li>数组作为方法参数传递，传递的参数是数组内存的地址。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">//调用方法，传递数组</span></span><br><span class="line">    printArray(arr);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 创建方法，方法接收数组类型的参数</span></span><br><span class="line"><span class="comment">   * 进行数组的遍历</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="数组作为方法返回值"><a href="#数组作为方法返回值" class="headerlink" title="数组作为方法返回值"></a>数组作为方法返回值</h4><ul><li>数组作为方法的返回值，返回的是数组的内存地址<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用方法，接收数组的返回值</span></span><br><span class="line">  <span class="comment">//接收到的是数组的内存地址</span></span><br><span class="line">  <span class="keyword">int</span>[] arr = getArray();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  System.out.println(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建方法，返回值是数组类型</span></span><br><span class="line"><span class="comment"> * return返回数组的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getArray() &#123;</span><br><span class="line">  <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">  <span class="comment">//返回数组的地址，返回到调用者</span></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数组概念&quot;&gt;&lt;a href=&quot;#数组概念&quot; class=&quot;headerlink&quot; title=&quot;数组概念&quot;&gt;&lt;/a&gt;数组概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;数组概念： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="https://jasondcq.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jasondcq.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes是什么</title>
    <link href="https://jasondcq.github.io/Kubernetes%E6%A6%82%E8%BF%B0/"/>
    <id>https://jasondcq.github.io/Kubernetes%E6%A6%82%E8%BF%B0/</id>
    <published>2020-05-24T13:46:00.000Z</published>
    <updated>2020-05-24T13:52:58.281Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Kubernetes是什么及作用"><a href="#Kubernetes是什么及作用" class="headerlink" title="Kubernetes是什么及作用"></a>Kubernetes是什么及作用</h4><p>Kubernetes(K8S)是Google在2014年发布的一个开源项目，用于自动化容器化应用程序的部署、扩展和管理。Kubernetes通常结合docker容器工作，并且整合多个运行着docker容器的主机集群。 官网地址<a href="https://Kubernetes.io中文社区" target="_blank" rel="noopener">https://Kubernetes.io中文社区</a> <a href="https://www.kubernetes.org.cn/docs" target="_blank" rel="noopener">https://www.kubernetes.org.cn/docs</a></p><p>Kubernetes的目标是让部署容器化的应用简单并且高效，Kubernetes一个核心特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望运行。以下是Kubernetes相关特性：</p><ul><li>自动包装<br>根据资源需求和其他约束自动放置容器，同时不会牺牲可用性，混合关  键和最大努力的工作负载，以提高资源利用率并节省更多资源。</li><li>横向缩放<br>使用简单的命令或 UI，或者根据 CPU 的使用情况自动调整应用程序副本数。</li><li>自动部署和回滚<br>Kubernetes 逐渐部署对应用程序或其配置的更改，同时监视应用程序运行状况，以确保它不会同时终止所有实例。 如果出现问题，Kubernetes会为您恢复更改，利用日益增长的部署解决方案的生态系统。</li><li>存储编排<br>自动安装您所选择的存储系统，无论是本地存储，如公有云提供商 GCP 或 AWS, 还是网络存储系统 NFS,iSCSI, Gluster, Ceph, Cinder, 或 Flocker。</li><li>自我修复<br>重新启动失败的容器，在节点不可用时，替换和重新编排节点上的容器，终止不对用户定义的健康检查做出响应的容器，并且不会在客户端准备投放之前将其通告给客户端。</li><li>服务发现和负载均衡<br>不需要修改您的应用程序来使用不熟悉的服务发现机制，Kubernetes 为容器提供了自己的 IP 地址和一组容器的单个 DNS 名称，并可以在它们之间进行负载均衡。</li><li>密钥和配置管理<br>部署和更新密钥和应用程序配置，不会重新编译您的镜像，不会在堆栈配置中暴露密钥(secrets)。</li><li>批处理<br>除了服务之外，Kubernetes还可以管理您的批处理和 CI 工作负载，如果需要，替换出现故障的容器。</li></ul><h4 id="使用Kubernetes能做什么"><a href="#使用Kubernetes能做什么" class="headerlink" title="使用Kubernetes能做什么"></a>使用Kubernetes能做什么</h4><p>Kubernetes是一个全新的基于容器技术的分布式架构领先方案（源于Brog，是google十几年经验的结晶）；<br>Kubernetes是一个开放的开发平台（无侵入性，现有系统很容器迁移到Kubernetes上）；Kubernetes是一个完备的分布式系统支撑平台（完善的集群管理能力）</p><p>使用Kubernetes可以在物理或虚拟机的Kubernetes集群上运行容器化应用，Kubernetes能够提供一个以容器为中心的基础架构，满足在生产环境中运行应用的一些常见需求，如:</p><ul><li>多个进程协同工作</li><li>存储系统挂载</li><li>Distributing secrets</li><li>应用健康检测</li><li>应用实例的复制</li><li>Pod自动伸缩/扩展</li><li>Naming and discovering</li><li>负载均衡</li><li>滚动更新</li><li>资源监控</li><li>日志访问</li><li>调度应用程序</li><li>提供认证和授权</li></ul><h4 id="为什么使用Kubernetes"><a href="#为什么使用Kubernetes" class="headerlink" title="为什么使用Kubernetes"></a>为什么使用Kubernetes</h4><p>使用Kubernetes最直接的感受就是我们可以轻装上阵的开发复杂的系统了；其次Kubernetes是在全面拥抱微服务架构（微服务的核心就是将一个巨大的单体应用拆分成很多小的互相连接的微服务，一个微服务后面可能是多个实例副本在支撑，副本数量可以随着系统负荷的变化而动态调整）；最后Kubernetes系统架构具备超强的横向扩展能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Kubernetes是什么及作用&quot;&gt;&lt;a href=&quot;#Kubernetes是什么及作用&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes是什么及作用&quot;&gt;&lt;/a&gt;Kubernetes是什么及作用&lt;/h4&gt;&lt;p&gt;Kubernetes(K8S
      
    
    </summary>
    
    
      <category term="k8s" scheme="https://jasondcq.github.io/categories/k8s/"/>
    
    
      <category term="k8s" scheme="https://jasondcq.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Docker私有仓库构建</title>
    <link href="https://jasondcq.github.io/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%9E%84%E5%BB%BA/"/>
    <id>https://jasondcq.github.io/Docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%9E%84%E5%BB%BA/</id>
    <published>2020-05-24T13:33:00.000Z</published>
    <updated>2020-05-24T13:37:26.829Z</updated>
    
    <content type="html"><![CDATA[<h4 id="私有仓库搭建与配置"><a href="#私有仓库搭建与配置" class="headerlink" title="私有仓库搭建与配置"></a>私有仓库搭建与配置</h4><p>1、拉取私有仓库镜像（此步省略）<br>命令：<code>docker pull registry</code></p><p>2、启动私有仓库容器<br>命令：<code>docker run -di --name=registry -p 5000:5000 registry</code></p><p>3、打开浏览器 输入地址<a href="http://192.168.184.141:5000/v2/_catalog看到" target="_blank" rel="noopener">http://192.168.184.141:5000/v2/_catalog看到</a> {“repositories”:[]} 表示私有仓库搭建成功并且内容为空</p><p>4、修改daemon.json<br>命令：<code>{&quot;insecure-registries&quot;:[&quot;192.168.184.141:5000&quot;]}</code><br>此步用于让 docker信任私有仓库地址</p><p>5、重启docker 服务<br>命令：<code>systemctl restart docker</code></p><h4 id="镜像上传至私有仓库"><a href="#镜像上传至私有仓库" class="headerlink" title="镜像上传至私有仓库"></a>镜像上传至私有仓库</h4><p>1、标记此镜像为私有仓库的镜像<br>命令：<code>docker tag jdk1.8 192.168.184.141:5000/jdk1.8</code></p><p>2、再次启动私服容器<br>命令：<code>docker start registry</code></p><p>3、上传标记的镜像<br>命令：<code>docker push 192.168.184.141:5000/jdk1.8</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;私有仓库搭建与配置&quot;&gt;&lt;a href=&quot;#私有仓库搭建与配置&quot; class=&quot;headerlink&quot; title=&quot;私有仓库搭建与配置&quot;&gt;&lt;/a&gt;私有仓库搭建与配置&lt;/h4&gt;&lt;p&gt;1、拉取私有仓库镜像（此步省略）&lt;br&gt;命令：&lt;code&gt;docker pull r
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile</title>
    <link href="https://jasondcq.github.io/Dockerfile/"/>
    <id>https://jasondcq.github.io/Dockerfile/</id>
    <published>2020-05-24T13:21:00.000Z</published>
    <updated>2020-05-24T13:32:27.259Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h4><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。<br>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；<br>2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；<br>3、对于运维人员：在部署时，可以实现应用的无缝移植；</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令</th><th align="center">作用</th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td align="center">定义了使用哪个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER user_name</td><td align="center">声明镜像的创建者</td></tr><tr><td>ENV key value</td><td align="center">设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td align="center">是Dockerfile的核心部分(可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td align="center">将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td align="center">和ADD相似，但是如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td align="center">设置工作目录</td></tr></tbody></table><h4 id="使用脚本创建镜像"><a href="#使用脚本创建镜像" class="headerlink" title="使用脚本创建镜像"></a>使用脚本创建镜像</h4><p>步骤：<br>1、创建目录<br>命令：<code>mkdir –p /usr/local/dockerjdk8</code></p><p>2、下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录</p><p>3、创建文件Dockerfile <code>vim Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#依赖镜像名称和ID</span></span><br><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="comment">#指定镜像创建者信息</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> ITCAST</span><br><span class="line"><span class="comment">#切换工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usrRUN mkdir /usr/<span class="built_in">local</span>/java</span></span><br><span class="line"><span class="comment">#ADD 是相对路径jar,把java添加到容器中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jdk-8u171-linux-x64.tar.gz /usr/<span class="built_in">local</span>/java/</span></span><br><span class="line"><span class="comment">#配置java环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="number">8.0</span>_171</span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME $JAVA_HOME/jre</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line"><span class="keyword">ENV</span> PATH $JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>4、执行命令构建镜像<br>命令：<code>docker build -t=&#39;jdk1.8&#39; .</code><br>注意后边的空格和点，不要省略</p><p>5、查看镜像是否建立完成<br>命令：<code>docker images</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是Dockerfile&quot;&gt;&lt;a href=&quot;#什么是Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;什么是Dockerfile&quot;&gt;&lt;/a&gt;什么是Dockerfile&lt;/h4&gt;&lt;p&gt;Dockerfile是由一系列命令和参数构成的脚本，
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker迁移与备份</title>
    <link href="https://jasondcq.github.io/Docker%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%87%E4%BB%BD/"/>
    <id>https://jasondcq.github.io/Docker%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%87%E4%BB%BD/</id>
    <published>2020-05-24T13:17:00.000Z</published>
    <updated>2020-05-24T13:19:36.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h3><h4 id="容器保存为镜像"><a href="#容器保存为镜像" class="headerlink" title="容器保存为镜像"></a>容器保存为镜像</h4><p>我们可以通过以下命令将容器保存为镜像：<code>docker commit mynginx mynginx_i</code></p><h4 id="镜像备份"><a href="#镜像备份" class="headerlink" title="镜像备份"></a>镜像备份</h4><p>我们可以通过以下命令将镜像保存为tar 文件：<code>docker save -o mynginx.tar mynginx_i</code></p><h4 id="镜像恢复与迁移"><a href="#镜像恢复与迁移" class="headerlink" title="镜像恢复与迁移"></a>镜像恢复与迁移</h4><p>首先我们先删除掉<code>mynginx_img</code>镜像 然后执行此命令进行恢复：<code>docker load -i mynginx.tar</code> </p><ul><li>-i 输入的文件<br>执行后再次查看镜像，可以看到镜像已经恢复</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;迁移与备份&quot;&gt;&lt;a href=&quot;#迁移与备份&quot; class=&quot;headerlink&quot; title=&quot;迁移与备份&quot;&gt;&lt;/a&gt;迁移与备份&lt;/h3&gt;&lt;h4 id=&quot;容器保存为镜像&quot;&gt;&lt;a href=&quot;#容器保存为镜像&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker应用部署</title>
    <link href="https://jasondcq.github.io/Docker%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/"/>
    <id>https://jasondcq.github.io/Docker%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2020-05-24T12:51:00.000Z</published>
    <updated>2020-05-24T13:00:58.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><h4 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a>MySQL部署</h4><p>1、拉取mysql镜像<br>命令：<code>docker pull centos/mysql-57-centos7</code></p><p>2、创建容器<br>命令：<code>docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</code></p><ul><li>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</li><li>-e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码</li></ul><p>3、远程登录mysql<br>连接宿主机的IP ,指定端口为33306</p><h4 id="tomcat部署"><a href="#tomcat部署" class="headerlink" title="tomcat部署"></a>tomcat部署</h4><p>1、拉取镜像<br>命令：<code>docker pull tomcat:7-jre7</code></p><p>2、创建容器，创建容器 -p表示地址映射<br>命令：<code>docker run -di --name=mytomcat -p 9000:8080-v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7</code></p><h4 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h4><p>1、拉取镜像<br>命令：<code>docker pull nginx</code></p><p>2、创建Nginx容器<br>命令：<code>docker run -di --name=mynginx -p 80:80 nginx</code></p><h4 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h4><p>1、拉取镜像<br>命令：<code>docker pull redis</code></p><p>2、创建容器<br>命令：<code>docker run -di --name=myredis -p 6379:6379 redis</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;应用部署&quot;&gt;&lt;a href=&quot;#应用部署&quot; class=&quot;headerlink&quot; title=&quot;应用部署&quot;&gt;&lt;/a&gt;应用部署&lt;/h3&gt;&lt;h4 id=&quot;MySQL部署&quot;&gt;&lt;a href=&quot;#MySQL部署&quot; class=&quot;headerlink&quot; title=&quot;MyS
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="https://jasondcq.github.io/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://jasondcq.github.io/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-05-24T12:05:00.000Z</published>
    <updated>2020-05-24T13:15:53.556Z</updated>
    
    <content type="html"><![CDATA[<h4 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h4><p>1、查看镜像：<code>docker images</code></p><p>列表参数说明：</p><ul><li>REPOSITORY：镜像名称</li><li>TAG：镜像标签</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像的创建日期（不是获取该镜像的日期）</li><li>SIZE：镜像大小<br>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</li></ul><p>只列出镜像ID：<code>docker images -q</code></p><p>2、搜索镜像：<code>docker search 镜像名称</code></p><p>列表参数说明：</p><ul><li>NAME：仓库名称</li><li>DESCRIPTION：镜像描述</li><li>STARS：用户评价，反应一个镜像的受欢迎程度</li><li>OFFICIAL：是否官方</li><li>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</li></ul><p>3、拉取镜像：<code>docker pull 镜像名称</code><br>拉取镜像就是从中央仓库中下载镜像到本地，例如，我要下载centos7镜像：<code>docker pull centos:7</code></p><p>4、删除镜像<br>按镜像ID删除镜像：<code>docker rmi 镜像ID</code><br>删除所有镜像：<code>docker rmi `docker images -q</code> 或 <code>docker rmi $(docker images -q)</code></p><h4 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h4><p>1、查看容器</p><ul><li>查看正在运行的容器： <code>docker ps</code></li><li>查看所有容器：<code>docker ps –a</code></li><li>查看最后一次运行的容器：<code>docker ps –l</code></li><li>查看停止的容器：<code>docker ps -f status=exited</code></li></ul><p>2、创建与启动容器</p><p>创建容器常用的参数说明：<br>创建容器命令：<code>docker run</code></p><ul><li>-i：表示运行容器</li><li>-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</li><li>–name :为创建的容器命名。</li><li>-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</li><li>-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</li><li>-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</li></ul><p>2.1、交互式方式创建容器：<code>docker run -it --name=容器名称 镜像名称:标签 /bin/bash</code>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态<br>退出当前容器<code>exit</code></p><p>2.2、守护式方式创建容器：<code>docker run -di --name=容器名称 镜像名称:标签</code><br>登录守护式容器方式：<code>docker exec -it 容器名称 (或者容器ID) /bin/bash</code></p><p>3、停止与启动容器</p><p>停止容器：<code>docker stop 容器名称（或者容器ID）</code><br>启动容器：<code>docker start 容器名称（或者容器ID）</code></p><p>4、文件拷贝</p><p>如果我们需要将文件拷贝到容器内可以使用<code>cp</code>命令：<code>docker cp 需要拷贝的文件或目录 容器名称:容器目录</code><br>也可以将文件从容器内拷贝出来：<code>docker cp 容器名称:容器目录 需要拷贝的文件或目录</code></p><p>5、目录挂载</p><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录<br>的文件从而去影响容器。 创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如：<code>docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7</code><br>如果你共享的是多级的目录，可能会出现权限不足的提示，这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 <code>--privileged=true</code> 来解决挂载的目录没有权限的问题</p><p>6、查看容器IP地址</p><p>我们可以通过以下命令查看容器运行的各种数据：<code>docker inspect 容器名称（容器ID）</code></p><p>也可以直接执行下面的命令直接输出IP地址：<code>docker inspect --format=&#39;&#39; 容器名称（容器ID）</code></p><p>7、删除容器</p><p>删除指定的容器：<code>docker rm 容器名称（容器ID）</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;镜像相关命令&quot;&gt;&lt;a href=&quot;#镜像相关命令&quot; class=&quot;headerlink&quot; title=&quot;镜像相关命令&quot;&gt;&lt;/a&gt;镜像相关命令&lt;/h4&gt;&lt;p&gt;1、查看镜像：&lt;code&gt;docker images&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;列表参数说明：&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装与启动</title>
    <link href="https://jasondcq.github.io/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>https://jasondcq.github.io/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8/</id>
    <published>2020-05-24T11:48:00.000Z</published>
    <updated>2020-05-24T12:05:08.367Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p><p>由于我们一般生产环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更<br>新。</p><p>1、yum包更新到最新<br>命令：<code>sudo yum update</code></p><p>2、安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper驱动依赖的<br>命令：<code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></p><p>3、设置yum源为阿里云<br>命令：<code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/dockerce/linux/centos/docker-ce.repo</code></p><p>4、安装docker<br>命令：<code>sudo yum install docker-ce</code></p><p>5、安装后查看docker版本<br>命令：<code>docker -v</code></p><h4 id="设置ustc的镜像或阿里云镜像加速"><a href="#设置ustc的镜像或阿里云镜像加速" class="headerlink" title="设置ustc的镜像或阿里云镜像加速"></a>设置ustc的镜像或阿里云镜像加速</h4><p>编辑该文件：<code>vi /etc/docker/daemon.json</code><br>在该文件中输入如下内容：<code>{ &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]}</code></p><h4 id="Docker的启动与停止"><a href="#Docker的启动与停止" class="headerlink" title="Docker的启动与停止"></a>Docker的启动与停止</h4><p>systemctl命令是系统服务管理器指令</p><p>1、启动docker：<code>systemctl start docker</code><br>2、停止docker：<code>systemctl stop docker</code><br>3、重启docker：<code>systemctl restart docker</code><br>4、查看docker状态：<code>systemctl status docker</code><br>5、开机启动：<code>systemctl enable docker</code><br>6、查看docker概要信息：<code>docker info</code><br>7、查看docker帮助文档：<code>docker --help</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;安装Docker&quot;&gt;&lt;a href=&quot;#安装Docker&quot; class=&quot;headerlink&quot; title=&quot;安装Docker&quot;&gt;&lt;/a&gt;安装Docker&lt;/h4&gt;&lt;p&gt;Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://jasondcq.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs快速学习系列(六) Vuex详解</title>
    <link href="https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E5%85%AD-Vuex%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E5%85%AD-Vuex%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-07T15:43:00.000Z</published>
    <updated>2020-05-08T03:03:46.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识Vuex"><a href="#认识Vuex" class="headerlink" title="认识Vuex"></a>认识Vuex</h3><h4 id="Vuex是做什么的"><a href="#Vuex是做什么的" class="headerlink" title="Vuex是做什么的?"></a>Vuex是做什么的?</h4><p>官方解释：<code>Vuex</code> 是一个专为 <code>Vue.js</code> 应用程序开发的状态管理模式</p><ul><li>它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</li><li><code>Vuex</code> 也集成到 <code>Vue</code> 的官方调试工具 <code>devtools</code> <code>extension</code>，提供了诸如零配置的 <code>time-travel</code> 调试、状态快照导入导出等高级调试功能</li></ul><p>状态管理到底是什么？</p><ul><li>状态管理模式、集中式存储管理这些名词听起来就非常高大上，让人捉摸不透，其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面，然后，将这个对象放在顶层的<code>Vue</code>实例中，让其他组件可以使用，那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？等等，如果是这样的话，为什么官方还要专门出一个插件<code>Vuex</code>呢？难道我们不能自己封装一个对象来管理吗？当然可以，只是我们要先想想<code>VueJS</code>带给我们最大的便利是什么呢？没错，就是响应式，如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢？当然也可以，只是自己封装可能稍微麻烦一些，不用怀疑，<code>Vuex</code>就是为了提供这样一个在多个组件间共享状态的插件，用它就可以了。</li></ul><h4 id="管理什么状态呢"><a href="#管理什么状态呢" class="headerlink" title="管理什么状态呢?"></a>管理什么状态呢?</h4><p>有什么状态时需要我们在多个组件间共享的呢？如果你做过大型开发，你一定遇到过多个状态，在多个界面间的共享问题，比如用户的登录状态、用户名称、头像、地理位置信息等等，比如商品的收藏、购物车中的物品等等，这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的。</p><h4 id="单界面的状态管理"><a href="#单界面的状态管理" class="headerlink" title="单界面的状态管理"></a>单界面的状态管理</h4><p>我们知道，要在单个组件中进行状态管理是一件非常简单的事情，什么意思呢？我们来看下面的图片：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/vuex/img_1.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>这图片中的三种东西，怎么理解呢？</p><ul><li><code>State</code>：不用多说，就是我们的状态。（你姑且可以当做就是<code>data</code>中的属性）</li><li><code>View</code>：视图层，可以针对<code>State</code>的变化，显示不同的信息。（这个好理解吧？）</li><li><code>Actions</code>：这里的<code>Actions</code>主要是用户的各种操作：点击、输入等等，会导致状态的改变</li></ul><h4 id="单界面状态管理的实现"><a href="#单界面状态管理的实现" class="headerlink" title="单界面状态管理的实现"></a>单界面状态管理的实现</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/vuex/img_2.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><ul><li>在这个案例中，我们有木有状态需要管理呢？没错，就是个数<code>counter</code></li><li><code>counter</code>需要某种方式被记录下来，也就是我们的<code>State</code></li><li><code>counter</code>目前的值需要被显示在界面中，也就是我们的<code>View</code>部分</li><li>界面发生某些操作时（我们这里是用户的点击，也可以是用户的<code>input</code>），需要去更新状态，也就是我们的<code>Actions</code></li></ul><h4 id="多界面状态管理"><a href="#多界面状态管理" class="headerlink" title="多界面状态管理"></a>多界面状态管理</h4><p>Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？</p><ul><li>多个试图都依赖同一个状态（一个状态改了，多个界面需要进行更新）</li><li>不同界面的<code>Actions</code>都想修改同一个状态（<code>Home.vue</code>需要修改，<code>Profile.vue</code>也需要修改这个状态）</li></ul><p>也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个试图，但是也有一些状态(状态a/状态b/状态c)属于多个试图共同想要维护的</p><ul><li>状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题</li><li>但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！</li><li>没错，Vuex就是为我们提供这个大管家的工具</li></ul><p>全局单例模式（大管家）</p><ul><li>我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理</li><li>之后，你们每个试图，按照我规定好的规定，进行访问和修改等操作</li><li>这就是Vuex背后的基本思想</li></ul><h4 id="Vuex状态管理图例"><a href="#Vuex状态管理图例" class="headerlink" title="Vuex状态管理图例"></a>Vuex状态管理图例</h4><p>一起在来看一副官方给出的图片</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/vuex/img_3.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="Vuex的基本使用"><a href="#Vuex的基本使用" class="headerlink" title="Vuex的基本使用"></a>Vuex的基本使用</h3><h4 id="简单的案例"><a href="#简单的案例" class="headerlink" title="简单的案例"></a>简单的案例</h4><p>首先，我们需要在某个地方存放我们的<code>Vuex</code>代码：</p><ul><li>这里，我们先创建一个文件夹<code>store</code>，并且在其中创建一个<code>index.js</code>文件</li><li>在<code>index.js</code>文件中写入如下代码：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/vuex/img_4.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="挂载到Vue实例中"><a href="#挂载到Vue实例中" class="headerlink" title="挂载到Vue实例中"></a>挂载到Vue实例中</h4><p>其次，我们让所有的<code>Vue</code>组件都可以使用这个<code>store</code>对象</p><ul><li>来到<code>main.js</code>文件，导入<code>store</code>对象，并且放在<code>new Vue</code>中</li><li>这样，在其他<code>Vue</code>组件中，我们就可以通过<code>this.$store</code>的方式，获取到这个<code>store</code>对象了</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/vuex/img_5.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="使用Vuex的count"><a href="#使用Vuex的count" class="headerlink" title="使用Vuex的count"></a>使用Vuex的count</h4><p>这就是使用<code>Vuex</code>最简单的方式了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/vuex/img_6.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>我们来对使用步骤，做一个简单的小节：</p><p>1、提取出一个公共的<code>store</code>对象，用于保存在多个组件中共享的状态<br>2、将<code>store</code>对象放置在<code>new Vue</code>对象中，这样可以保证在所有的组件中都可以使用到<br>3、在其他组件中使用<code>store</code>对象中保存的状态即可</p><ul><li>通过<code>this.$store.state.</code>属性的方式来访问状态</li><li>通过<code>this.$store.commit(&#39;mutation中方法&#39;)</code>来修改状态</li></ul><p>注意事项：</p><ul><li>我们通过提交<code>mutation</code>的方式，而非直接改变<code>store.state.count</code></li><li>这是因为<code>Vuex</code>可以更明确的追踪状态的变化，所以不要直接改变<code>store.state.count</code>的值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;认识Vuex&quot;&gt;&lt;a href=&quot;#认识Vuex&quot; class=&quot;headerlink&quot; title=&quot;认识Vuex&quot;&gt;&lt;/a&gt;认识Vuex&lt;/h3&gt;&lt;h4 id=&quot;Vuex是做什么的&quot;&gt;&lt;a href=&quot;#Vuex是做什么的&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Vuejs快速学习系列" scheme="https://jasondcq.github.io/categories/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vuejs" scheme="https://jasondcq.github.io/tags/Vuejs/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs快速学习系列(五) vue-router详解</title>
    <link href="https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E4%BA%94-vue-router%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E4%BA%94-vue-router%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-05-07T13:18:00.000Z</published>
    <updated>2020-05-07T15:52:40.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识路由"><a href="#认识路由" class="headerlink" title="认识路由"></a>认识路由</h3><h4 id="什么是路由？"><a href="#什么是路由？" class="headerlink" title="什么是路由？"></a>什么是路由？</h4><p>说起路由你想起了什么？</p><ul><li>路由是一个网络工程里面的术语</li><li>路由<code>routing</code>就是通过互联的网络把信息从源地址传输到目的地址的活动. — 维基百科</li></ul><p>路由器提供了两种机制: 路由和转送</p><ul><li>路由是决定数据包从来源到目的地的路径</li><li>转送将输入端的数据转移到合适的输出端</li></ul><p>路由中有一个非常重要的概念叫路由表</p><ul><li>路由表本质上就是一个映射表, 决定了数据包的指向</li></ul><h4 id="后端路由阶段"><a href="#后端路由阶段" class="headerlink" title="后端路由阶段"></a>后端路由阶段</h4><p>  早期的网站开发整个HTML页面是由服务器来渲染的，服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示。但是, 一个网站, 这么多页面服务器如何处理呢?</p><ul><li>一个页面有自己对应的网址, 也就是<code>URL</code></li><li><code>URL</code>会发送到服务器, 服务器会通过正则对该<code>URL</code>进行匹配, 并且最后交给一个<code>Controller</code>进行处理</li><li><code>Controller</code>进行各种处理, 最终生成<code>HTML</code>或者数据, 返回给前端.</li><li>这就完成了一个<code>IO</code>操作</li></ul><p>上面的这种操作, 就是后端路由.当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端。这种情况下渲染好的页面, 不需要单独加载任何的<code>js</code>和<code>css</code>, 可以直接交给浏览器展示, 这样也有利于<code>SEO</code>的优化。</p><p>后端路由的缺点：</p><ul><li>一种情况是整个页面的模块由后端人员来编写和维护的</li><li>另一种情况是前端开发人员如果要开发页面, 需要通过<code>PHP</code>和<code>Java</code>等语言来编写页面代码</li><li>而且通常情况下<code>HTML</code>代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情</li></ul><h4 id="前端路由阶段"><a href="#前端路由阶段" class="headerlink" title="前端路由阶段"></a>前端路由阶段</h4><p>前后端分离阶段：</p><ul><li>随着<code>Ajax</code>的出现, 有了前后端分离的开发模式</li><li>后端只提供<code>API</code>来返回数据, 前端通过<code>Ajax</code>获取数据, 并且可以通过<code>JavaScript</code>将数据渲染到页面中</li><li>这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上</li><li>并且当移动端<code>iOS/Android</code>出现后, 后端不需要进行任何处理, 依然使用之前的一套<code>API</code>即可</li><li>目前很多的网站依然采用这种模式开发</li></ul><p>单页面富应用阶段:</p><ul><li>其实<code>SPA</code>最主要的特点就是在前后端分离的基础上加了一层前端路由</li><li>也就是前端来维护一套路由规则</li></ul><p>前端路由的核心是什么呢？</p><ul><li>改变<code>URL</code>，但是页面不进行整体的刷新</li></ul><h3 id="前端的路由规则"><a href="#前端的路由规则" class="headerlink" title="前端的路由规则"></a>前端的路由规则</h3><h4 id="URL的hash"><a href="#URL的hash" class="headerlink" title="URL的hash"></a>URL的hash</h4><ul><li><code>URL</code>的<code>hash</code>也就是锚点(#), 本质上是改变<code>window.location</code>的<code>href</code>属性</li><li>我们可以通过直接赋值<code>location.hash</code>来改变<code>href</code>, 但是页面不发生刷新</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_1.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="HTML5的history模式：pushState"><a href="#HTML5的history模式：pushState" class="headerlink" title="HTML5的history模式：pushState"></a>HTML5的history模式：pushState</h4><p>history接口是<code>HTML5</code>新增的, 它有五种模式改变<code>URL</code>而不刷新页面<br>函数：<code>history.pushState()</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_2.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="HTML5的history模式：replaceState"><a href="#HTML5的history模式：replaceState" class="headerlink" title="HTML5的history模式：replaceState"></a>HTML5的history模式：replaceState</h4><p>函数<code>history.replaceState()</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_3.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="HTML5的history模式：go"><a href="#HTML5的history模式：go" class="headerlink" title="HTML5的history模式：go"></a>HTML5的history模式：go</h4><p>函数：<code>history.go()</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_4.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>上面只演示了三个方法,因为 <code>history.back()</code> 等价于 <code>history.go(-1)</code>,<code>history.forward()</code> 则等价于 <code>history.go(1)</code>,这三个接口等同于浏览器界面的前进后退.</p><h3 id="vue-router基础"><a href="#vue-router基础" class="headerlink" title="vue-router基础"></a>vue-router基础</h3><h4 id="认识vue-router"><a href="#认识vue-router" class="headerlink" title="认识vue-router"></a>认识vue-router</h4><p>目前前端流行的三大框架, 都有自己的路由实现：</p><ul><li><code>Angular</code>的<code>ngRouter</code></li><li><code>React</code>的<code>ReactRouter</code></li><li><code>Vue</code>的<code>vue-router</code></li></ul><p>当然, 我们的重点是<code>vue-router</code></p><ul><li><code>vue-router</code>是<code>Vue.js</code>官方的路由插件，它和<code>vue.js</code>是深度集成的，适合用于构建单页面应用</li><li>我们可以访问其官方网站对其进行学习: <code>https://router.vuejs.org/zh/</code></li></ul><p>vue-router是基于路由和组件的</p><ul><li>路由用于设定访问路径, 将路径和组件映射起来</li><li>在<code>vue-router</code>的单页面应用中, 页面的路径的改变就是组件的切换</li></ul><h4 id="安装和使用vue-router"><a href="#安装和使用vue-router" class="headerlink" title="安装和使用vue-router"></a>安装和使用vue-router</h4><p>直接使用<code>npm</code>来安装路由即可<br>1、步骤一: 安装<code>vue-router</code></p><ul><li><code>npm install vue-router --save</code></li></ul><p>2、步骤二: 在模块化工程中使用它(因为是一个插件, 所以可以通过<code>Vue.use()</code>来安装路由功能)</p><ul><li>第一步：导入路由对象，并且调用 <code>Vue.use(VueRouter)</code></li><li>第二步：创建路由实例，并且传入路由映射配置</li><li>第三步：在<code>Vue</code>实例中挂载创建的路由实例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span> </span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span> </span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br></pre></td></tr></table></figure><p>使用<code>vue-router</code>的步骤:<br>1、第一步: 创建路由组件<br>2、第二步: 配置路由映射: 组件和路径映射关系<br>3、第三步: 使用路由: 通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code></p><h4 id="创建router实例"><a href="#创建router实例" class="headerlink" title="创建router实例"></a>创建router实例</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_5.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="挂载到Vue实例中"><a href="#挂载到Vue实例中" class="headerlink" title="挂载到Vue实例中"></a>挂载到Vue实例中</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_6.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="创建路由组件"><a href="#创建路由组件" class="headerlink" title="创建路由组件"></a>创建路由组件</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_7.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="配置组件和路径的映射关系"><a href="#配置组件和路径的映射关系" class="headerlink" title="配置组件和路径的映射关系"></a>配置组件和路径的映射关系</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_8.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="使用路由"><a href="#使用路由" class="headerlink" title="使用路由"></a>使用路由</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_9.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p><router-link>: 该标签是一个<code>vue-router</code>中已经内置的组件, 它会被渲染成一个<code>&lt;a&gt;</code>标签<br><router-view>: 该标签会根据当前的路径, 动态渲染出不同的组件.<br>网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和<code>&lt;router-view&gt;</code>处于同一个等级<br>在路由切换时, 切换的是<code>&lt;router-view&gt;</code>挂载的组件, 其他内容不会发生改变</p><h4 id="最终效果如下"><a href="#最终效果如下" class="headerlink" title="最终效果如下"></a>最终效果如下</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_10.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><h4 id="路由的默认路径"><a href="#路由的默认路径" class="headerlink" title="路由的默认路径"></a>路由的默认路径</h4><p>我们这里还有一个不太好的实现</p><ul><li>默认情况下, 进入网站的首页, 我们希望<code>&lt;router-view&gt;</code>渲染首页的内容</li><li>但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以</li></ul><p>如何可以让路径默认跳到到首页, 并且<code>&lt;router-view&gt;</code>渲染首页组件呢?</p><ul><li>非常简单, 我们只需要配置多配置一个映射就可以了</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_11.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>配置解析:</p><ul><li>我们在<code>routes</code>中又配置了一个映射</li><li><code>path</code>配置的是根路径: /</li><li><code>redirect</code>是重定向, 也就是我们将根路径重定向到<code>/home</code>的路径下, 这样就可以得到我们想要的结果了</li></ul><h4 id="HTML5的History模式"><a href="#HTML5的History模式" class="headerlink" title="HTML5的History模式"></a>HTML5的History模式</h4><p>我们前面说过改变路径的方式有两种</p><ul><li><code>URL</code>的<code>hash</code></li><li><code>HTML5</code>的<code>history</code></li><li>默认情况下, 路径的改变使用的<code>URL</code>的<code>hash</code></li></ul><p>如果希望使用<code>HTML5</code>的<code>history</code>模式, 非常简单, 进行如下配置即可:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_12.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_13.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="router-link补充"><a href="#router-link补充" class="headerlink" title="router-link补充"></a>router-link补充</h4><p>1、在前面的<code>&lt;router-link&gt;</code>中, 我们只是使用了一个属性: <code>to</code>, 用于指定跳转的路径。<br>2、<code>&lt;router-link&gt;</code>还有一些其他属性:</p><ul><li><code>&lt;router-link to=&#39;/home&#39; tag=&#39;li&#39;&gt;</code></li><li>tag: <code>tag</code>可以指定<code>&lt;router-link&gt;</code>之后渲染成什么组件, 比如上面的代码会被渲染成一个<code>&lt;li&gt;</code>元素, 而不是<code>&lt;a&gt;</code></li><li>replace: <code>replace</code>不会留下<code>history</code>记录, 所以指定<code>replace</code>的情况下, 后退键返回不能返回到上一个页面中</li><li>active-class: 当<code>&lt;router-link&gt;</code>对应的路由匹配成功时, 会自动给当前元素设置一个<code>router-link-active</code>的<code>class</code>, 设置<code>active-class</code>可以修改默认的名称</li></ul><h4 id="修改linkActiveClass"><a href="#修改linkActiveClass" class="headerlink" title="修改linkActiveClass"></a>修改linkActiveClass</h4><p>该<code>class</code>具体的名称也可以通过<code>router</code>实例的属性进行修改</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_14.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>类：<code>exact-active-class</code> 类似于<code>active-class</code>, 只是在精准匹配下才会出现的<code>class</code>.后面看到嵌套路由时, 我们再看下这个属性.</p><h4 id="路由代码跳转"><a href="#路由代码跳转" class="headerlink" title="路由代码跳转"></a>路由代码跳转</h4><p>有时候, 页面的跳转可能需要执行对应的<code>JavaScript</code>代码, 这个时候, 就可以使用第二种跳转方式了,比如, 我们将代码修改如下: </p><p><img src="http://blog.dcq.kuryun.cn/vue/img/router/img_15.jpg" alt="avatar"></p><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>在某些情况下，一个页面的<code>path</code>路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：</p><ul><li><code>/user/aaaa</code>或<code>/user/bbbb</code></li><li>除了有前面的<code>/user</code>之外，后面还跟上了用户的<code>ID</code></li><li>这种<code>path</code>和<code>Component</code>的匹配关系，我们称之为动态路由(也是路由传递数据的一种方式)</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_17.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_18.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_19.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><h4 id="认识路由的懒加载"><a href="#认识路由的懒加载" class="headerlink" title="认识路由的懒加载"></a>认识路由的懒加载</h4><p>官方给出了解释:</p><ul><li>当打包构建应用时，<code>Javascript</code> 包会变得非常大，影响页面加载</li><li>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</li></ul><p>官方在说什么呢?</p><ul><li>首先, 我们知道路由中通常会定义很多不同的页面</li><li>这个页面最后被打包在哪里呢? 一般情况下, 是放在一个<code>js</code>文件中</li><li>但是, 页面这么多放在一个<code>js</code>文件中, 必然会造成这个页面非常的大</li><li>如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况.</li><li>如何避免这种情况呢? 使用路由懒加载就可以了</li></ul><p>路由懒加载做了什么?</p><ul><li>路由懒加载的主要作用就是将路由对应的组件打包成一个个的<code>js</code>代码块</li><li>只有在这个路由被访问到的时候, 才加载对应的组件</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_20.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="懒加载的方式"><a href="#懒加载的方式" class="headerlink" title="懒加载的方式"></a>懒加载的方式</h4><p>1、方式一: 结合<code>Vue</code>的异步组件和<code>Webpack</code>的代码分析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">resolve</span> =&gt;</span> &#123; <span class="built_in">require</span>.ensure([<span class="string">'../components/Home.vue'</span>], () =&gt; &#123; resolve(<span class="built_in">require</span>(<span class="string">'../components/Home.vue'</span>)) &#125;)&#125;;</span><br></pre></td></tr></table></figure><p>2、方式二: AMD写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'../components/About.vue'</span>], resolve);</span><br></pre></td></tr></table></figure><p>3、方式三: 在<code>ES6</code>中, 我们可以有更加简单的写法来组织<code>Vue</code>异步组件和<code>Webpack</code>的代码分割</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Home.vue'</span>)</span><br></pre></td></tr></table></figure><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><h4 id="认识嵌套路由"><a href="#认识嵌套路由" class="headerlink" title="认识嵌套路由"></a>认识嵌套路由</h4><p>嵌套路由是一个很常见的功能</p><ul><li>比如在<code>home</code>页面中, 我们希望通过<code>/home/news</code>和<code>/home/message</code>访问一些内容</li><li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件</li></ul><p>路径和组件的关系如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_21.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>实现嵌套路由有两个步骤:</p><ul><li>创建对应的子组件, 并且在路由映射中配置对应的子路由</li><li>在组件内部使用<code>&lt;router-view&gt;</code>标签</li></ul><h4 id="嵌套路由实现"><a href="#嵌套路由实现" class="headerlink" title="嵌套路由实现"></a>嵌套路由实现</h4><p>定义两个组件:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_22.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_23.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_24.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_25.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="嵌套默认路径"><a href="#嵌套默认路径" class="headerlink" title="嵌套默认路径"></a>嵌套默认路径</h4><p>嵌套路由也可以配置默认的路径, 配置方式如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_26.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>为了演示传递参数, 我们这里再创建一个组件, 并且将其配置好</p><ul><li>第一步: 创建新的组件<code>Profile.vue</code></li><li>第二步: 配置路由映射</li><li>第三步: 添加跳转的<code>&lt;router-link&gt;</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_27.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_28.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_29.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="传递参数的方式"><a href="#传递参数的方式" class="headerlink" title="传递参数的方式"></a>传递参数的方式</h4><p>传递参数主要有两种类型: <code>params</code>和<code>query</code><br>params的类型:</p><ul><li>配置路由格式: <code>/router/:id</code></li><li>传递的方式: 在<code>path</code>后面跟上对应的值</li><li>传递后形成的路径: <code>/router/123</code>, <code>/router/abc</code></li></ul><p>query的类型:</p><ul><li>配置路由格式: <code>/router</code>, 也就是普通配置</li><li>传递的方式: 对象中使用<code>query</code>的<code>key</code>作为传递方式</li><li>传递后形成的路径: <code>/router?id=123</code>, <code>/router?id=abc</code></li></ul><p>如何使用它们呢? 也有两种方式: <code>&lt;router-link&gt;</code>的方式和<code>JavaScript</code>代码方式</p><h4 id="传递参数方式一"><a href="#传递参数方式一" class="headerlink" title="传递参数方式一: "></a>传递参数方式一: <router-link></h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_30.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="传递参数方式二-JavaScript代码"><a href="#传递参数方式二-JavaScript代码" class="headerlink" title="传递参数方式二: JavaScript代码"></a>传递参数方式二: JavaScript代码</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_31.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h4><p>获取参数通过<code>$route</code>对象获取的</p><ul><li>在使用了 <code>vue-router</code> 的应用中，路由对象会被注入每个组件中，赋值为 <code>this.$route</code> ，并且当路由切换时，路由对象会被更新</li></ul><p>通过<code>$route</code>获取传递的信息如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_32.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="route和-router是有区别的"><a href="#route和-router是有区别的" class="headerlink" title="$route和$router是有区别的"></a>$route和$router是有区别的</h4><p>注意：<code>$route</code>和<code>$router</code>是有区别的</p><ul><li><code>$router</code>为<code>VueRouter</code>实例，想要导航到不同<code>URL</code>，则使用<code>$router.push</code>方法</li><li><code>$route</code>为当前<code>router</code>跳转对象里面可以获取<code>name</code>、<code>path</code>、<code>query</code>、<code>params</code>等</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_33.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><h4 id="为什么使用导航守卫"><a href="#为什么使用导航守卫" class="headerlink" title="为什么使用导航守卫?"></a>为什么使用导航守卫?</h4><p>我们来考虑一个需求: 在一个<code>SPA</code>应用中, 如何改变网页的标题呢?</p><ul><li>网页标题是通过<code>&lt;title&gt;</code>来显示的, 但是<code>SPA</code>只有一个固定的<code>HTML</code>, 切换不同的页面时, 标题并不会改变</li><li>但是我们可以通过<code>JavaScript</code>来修改<code>&lt;title&gt;</code>的内容.window.document.title = ‘新的标题’</li><li>那么在<code>Vue</code>项目中, 在哪里修改? 什么时候修改比较合适呢?</li></ul><p>普通的修改方式:</p><ul><li>我们比较容易想到的修改标题的位置是每一个路由对应的组件<code>.vue</code>文件中.</li><li>通过<code>mounted</code>声明周期函数, 执行对应的代码进行修改即可</li><li>但是当页面比较多时, 这种方式不容易维护(因为需要在多个页面执行类似的代码).</li></ul><p>有没有更好的办法呢? 使用导航守卫即可.<br>什么是导航守卫?</p><ul><li><code>vue-router</code>提供的导航守卫主要用来监听监听路由的进入和离开的</li><li><code>vue-router</code>提供了<code>beforeEach</code>和<code>afterEach</code>的钩子函数, 它们会在路由即将改变前和改变后触发.</li></ul><h4 id="导航守卫使用"><a href="#导航守卫使用" class="headerlink" title="导航守卫使用"></a>导航守卫使用</h4><p>我们可以利用<code>beforeEach</code>来完成标题的修改.</p><ul><li>首先, 我们可以在钩子当中定义一些标题, 可以利用<code>meta</code>来定义</li><li>其次, 利用导航守卫,修改我们的标题</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_34.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_35.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>导航钩子的三个参数解析:</p><ul><li><code>to</code>: 即将要进入的目标的路由对象</li><li><code>from</code>: 当前导航即将要离开的路由对象</li><li><code>next</code>: 调用该方法后, 才能进入下一个钩子</li></ul><p>如果是后置钩子, 也就是<code>afterEach</code>, 不需要主动调用<code>next()</code>函数.<br>上面我们使用的导航守卫, 被称之为全局守卫.</p><ul><li>路由独享的守卫</li><li>组件内的守卫</li></ul><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><h4 id="keep-alive遇见vue-router"><a href="#keep-alive遇见vue-router" class="headerlink" title="keep-alive遇见vue-router"></a>keep-alive遇见vue-router</h4><p>keep-alive 是 <code>Vue</code> 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染.</p><ul><li>它们有两个非常重要的属性</li><li><code>include</code> - 字符串或正则表达，只有匹配的组件会被缓存</li><li><code>exclude</code> - 字符串或正则表达式，任何匹配的组件都不会被缓存</li></ul><p>router-view 也是一个组件，如果直接被包在 <code>keep-alive</code> 里面，所有路径匹配到的视图组件都会被缓存：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/router/img_36.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;认识路由&quot;&gt;&lt;a href=&quot;#认识路由&quot; class=&quot;headerlink&quot; title=&quot;认识路由&quot;&gt;&lt;/a&gt;认识路由&lt;/h3&gt;&lt;h4 id=&quot;什么是路由？&quot;&gt;&lt;a href=&quot;#什么是路由？&quot; class=&quot;headerlink&quot; title=&quot;什么是路由
      
    
    </summary>
    
    
      <category term="Vuejs快速学习系列" scheme="https://jasondcq.github.io/categories/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vuejs" scheme="https://jasondcq.github.io/tags/Vuejs/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs快速学习系列(四) Vue CLI相关</title>
    <link href="https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E5%9B%9B-Vue-CLI%E7%9B%B8%E5%85%B3/"/>
    <id>https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E5%9B%9B-Vue-CLI%E7%9B%B8%E5%85%B3/</id>
    <published>2020-05-07T12:34:00.000Z</published>
    <updated>2020-05-07T15:53:44.024Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue Cli"></a>Vue Cli</h3><h4 id="什么是Vue-CLI"><a href="#什么是Vue-CLI" class="headerlink" title="什么是Vue CLI"></a>什么是Vue CLI</h4><p>如果你只是简单写几个<code>Vue</code>的<code>Demo</code>程序, 那么你不需要<code>Vue CLI</code>，如果你在开发大型项目, 那么你需要, 并且必然需要使用<code>Vue CLI</code>。</p><ul><li>使用<code>Vue.js</code>开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情</li><li>如果每个项目都要手动完成这些工作，那无以效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情</li></ul><p>CLI是什么意思?</p><ul><li>CLI是<code>Command-Line Interface</code>, 翻译为命令行界面, 但是俗称脚手架</li><li>Vue CLI是一个官方发布 <code>vue.js</code> 项目脚手架</li><li>使用 <code>vue-cli</code> 可以快速搭建<code>Vue</code>开发环境以及对应的<code>webpack</code>配置</li></ul><h4 id="Vue-CLI使用前提-Node"><a href="#Vue-CLI使用前提-Node" class="headerlink" title="Vue CLI使用前提 - Node"></a>Vue CLI使用前提 - Node</h4><p>1、安装NodeJS</p><ul><li>可以直接在官方网站中下载安装</li><li>网址: <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></li></ul><p>2、检测安装的版本</p><ul><li>默认情况下自动安装<code>Node</code>和<code>NPM</code></li><li>Node环境要求8.9以上或者更高版本<code>node -v</code>，<code>npm -v</code></li></ul><p>3、什么是NPM呢?</p><ul><li>NPM的全称是Node Package Manager</li><li>是一个<code>NodeJS</code>包管理和分发工具，已经成为了非官方的发布<code>Node</code>模块（包）的标准</li><li>后续我们会经常使用<code>NPM</code>来安装一些开发过程中依赖包</li></ul><p>4、cnpm安装</p><ul><li>由于国内直接使用 <code>npm</code> 的官方镜像是非常慢的，这里推荐使用淘宝 <code>NPM</code> 镜像。</li><li>你可以使用淘宝定制的 <code>cnpm</code> (gzip 压缩支持) 命令行工具代替默认的 <code>npm</code></li><li>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li><li>这样就可以使用 cnpm 命令来安装模块了：</li><li>cnpm install [name]</li></ul><h4 id="Vue-CLI使用前提-Webpack"><a href="#Vue-CLI使用前提-Webpack" class="headerlink" title="Vue CLI使用前提 - Webpack"></a>Vue CLI使用前提 - Webpack</h4><p>Vue.js官方脚手架工具就使用了<code>webpack</code>模板</p><ul><li>对所有的资源会压缩等优化操作</li><li>它在开发过程中提供了一套完整的功能，能够使得我们开发过程中变得高效</li></ul><p>Webpack的全局安装: <code>npm install webpack -g</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cli/img_1.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="Vue-CLI的使用"><a href="#Vue-CLI的使用" class="headerlink" title="Vue CLI的使用"></a>Vue CLI的使用</h4><p>安装<code>Vue</code>脚手架:<code>npm install -g @vue/cli</code></p><p>Vue CLI3初始化项目: <code>vue create my-project</code></p><p>CLI3项目目录结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cli/img_2.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="配置去哪里了？"><a href="#配置去哪里了？" class="headerlink" title="配置去哪里了？"></a>配置去哪里了？</h4><p>UI方面的配置</p><ul><li>启动配置服务器：<code>vue ui</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cli/img_3.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cli/img_4.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="自定义配置：起别名"><a href="#自定义配置：起别名" class="headerlink" title="自定义配置：起别名"></a>自定义配置：起别名</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cli/img_5.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue-Cli&quot;&gt;&lt;a href=&quot;#Vue-Cli&quot; class=&quot;headerlink&quot; title=&quot;Vue Cli&quot;&gt;&lt;/a&gt;Vue Cli&lt;/h3&gt;&lt;h4 id=&quot;什么是Vue-CLI&quot;&gt;&lt;a href=&quot;#什么是Vue-CLI&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Vuejs快速学习系列" scheme="https://jasondcq.github.io/categories/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vuejs" scheme="https://jasondcq.github.io/tags/Vuejs/"/>
    
  </entry>
  
  <entry>
    <title>Mac修复&#39;CoreFoundation/CoreFoundation.h&#39; file not found问题</title>
    <link href="https://jasondcq.github.io/Mac%E4%BF%AE%E5%A4%8D-CoreFoundation-CoreFoundation-h-file-not-found%E9%97%AE%E9%A2%98/"/>
    <id>https://jasondcq.github.io/Mac%E4%BF%AE%E5%A4%8D-CoreFoundation-CoreFoundation-h-file-not-found%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-03T12:54:00.000Z</published>
    <updated>2020-05-03T12:58:15.567Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修复’CoreFoundation-CoreFoundation-h’-file-not-found"><a href="#修复’CoreFoundation-CoreFoundation-h’-file-not-found" class="headerlink" title="修复’CoreFoundation/CoreFoundation.h’ file not found"></a>修复’CoreFoundation/CoreFoundation.h’ file not found</h3><p>在<code>macOS 10.15</code>下<code>/System/Library/Frameworks/</code>缺少很多头/库文件，会导致很多软件编译失败。比如:CoreFoundation（找不到#include &lt;CoreFoundation/CoreFoundation.h&gt;）解决方案如下：</p><p>$ <code>sudo mount -uw /</code> # 根目录挂载为可读写，否则无法在/usr/下建立文件，本修改重启前有效。<br>$ <code>sudo ln -s &quot;$(xcrun --show-sdk-path)/usr/include&quot; /usr/include$ export SDKROOT=&quot;$(xcrun --show-sdk-path)&quot;</code> # 设置环境变量<br>$ <code>echo &quot;export SDKROOT=\&quot;\$(xcrun --show-sdk-path)\&quot;&quot; &gt;&gt; ~/.bash_profile</code> # zsh的自行搞定<br>$ <code>sudo DevToolsSecurity -enable</code> # 将系统置于开发模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;修复’CoreFoundation-CoreFoundation-h’-file-not-found&quot;&gt;&lt;a href=&quot;#修复’CoreFoundation-CoreFoundation-h’-file-not-found&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="mac工具" scheme="https://jasondcq.github.io/categories/mac%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="mac工具" scheme="https://jasondcq.github.io/tags/mac%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Mac使用brew安装memcached、redis、mysql</title>
    <link href="https://jasondcq.github.io/Mac%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85memcached/"/>
    <id>https://jasondcq.github.io/Mac%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85memcached/</id>
    <published>2020-04-24T06:13:00.000Z</published>
    <updated>2020-05-24T11:45:31.845Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HomeBrew安装"><a href="#HomeBrew安装" class="headerlink" title="HomeBrew安装"></a>HomeBrew安装</h4><p>1、<code>homebrew</code> 是 <code>macOS</code> 缺失的软件包管理器,譬如可以下载 <code>mysql</code>、<code>redis</code>、<code>wget</code> 等等.操作系统：macOS High Sierra Version 10.14.5<br>2、<code>Homebrew</code> 会将软件包安装到独立目录,并将其文件软链接至 <code>/usr/local</code> . <code>Homebrew</code> 不会将文件安装到它本身目录之外,所以您可将 <code>Homebrew</code> 安装到任意位置.<br>3、<code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code><br>4、官方网站<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></p><h4 id="HomeBrew的基本使用方法："><a href="#HomeBrew的基本使用方法：" class="headerlink" title="HomeBrew的基本使用方法："></a>HomeBrew的基本使用方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brew search **  &#x2F;&#x2F;查找某个软件包</span><br><span class="line">brew list  &#x2F;&#x2F;列出已经安装的软件的包</span><br><span class="line">brew install ** &#x2F;&#x2F;安装某个软件包,默认安装的是稳定版本</span><br><span class="line">brew uninstall **&#x2F;&#x2F;卸载某个软件的包</span><br><span class="line">brew upgrade ** &#x2F;&#x2F;更新某个软件包</span><br><span class="line">brew info ** &#x2F;&#x2F;查看指定软件包的说明</span><br><span class="line">brew cache clean &#x2F;&#x2F;清理缓存</span><br></pre></td></tr></table></figure><h4 id="memcached安装"><a href="#memcached安装" class="headerlink" title="memcached安装"></a>memcached安装</h4><p>1、使用命令<code>brew info memcached</code>检查是否已安装memcached及其依赖包情况</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/mactool/img/img_1.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>2、如上图所示，<code>memcached</code>的依赖包为<code>libevent</code>，如果未安装<code>libevent</code>（会打个红色的X），则需要首先查看<code>libevent</code>安装的依赖包，检查<code>libevent</code>的依赖包是否安装，使用命令<code>brew info libevent</code>:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/mactool/img/img_2.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>3、未安装的依赖会打一个红色的X，安装打X依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install doxygen</span><br><span class="line">brew install libtool</span><br></pre></td></tr></table></figure><p>4、依赖包安装完后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install libevent</span><br><span class="line">brew install memcached</span><br></pre></td></tr></table></figure><p>5、安装完成，启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动</span><br><span class="line">brew services start memcached</span><br><span class="line">&#x2F;&#x2F;停止</span><br><span class="line">brew services stop memcached</span><br><span class="line">&#x2F;&#x2F;重启</span><br><span class="line">brew services restart memcached</span><br><span class="line">&#x2F;&#x2F;查看所有运行的服务</span><br><span class="line">brew services list</span><br></pre></td></tr></table></figure><h4 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h4><p>1、安装包管理器最新版本<code>brew install redis</code></p><p>2、安装指定版本<code>brew install redis@4.0</code></p><p>3、<code>/usr/local/etc</code> 下修改<code>redis.config</code><br>找到<code>daemonize no</code> 改成<code>yes</code>以守护进程的方式启动配置环境变量echo ‘export PATH=”/usr/local/opt/redis@3.2/bin:$PATH”‘ &gt;&gt; ~/.zshrc</p><p>4、启动:<code>brew services start redis</code>或者使用<code>redis-server /usr/local/etc/redis.conf</code>启动</p><p>5、查看进程<code>ps axu | grep redis</code></p><p>6、关闭<code>redis-cli shutdown</code></p><p>7、杀死<code>sudo pkill redis-server</code></p><h4 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install mysql</span><br><span class="line">brew info mysql</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure><p>运行 <code>brew services start mysql</code> 可以后台启动 <code>mysql</code>,运行 <code>mysql.server start</code> 前台启动 <code>mysql</code>(关闭控制台,服务停止),当安装完成之后需要进行一些设置。</p><p>设置密码需先启动 <code>mysql</code> 服务 <code>mysql_secure_installation</code></p><p>设置完之后测试一下，连接mysql: <code>mysql -u root -p 123456</code></p><h4 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~&#x2F;Library&#x2F;LaunchAgents</span><br><span class="line"></span><br><span class="line">ln -sfv &#x2F;usr&#x2F;local&#x2F;opt&#x2F;mysql&#x2F;*.plist ~&#x2F;Library&#x2F;LaunchAgents</span><br><span class="line"></span><br><span class="line">find &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;mysql&#x2F; -name &quot;homebrew.mxcl.mysql.plist&quot; -exec cp &#123;&#125; ~&#x2F;Library&#x2F;LaunchAgents&#x2F; \;</span><br><span class="line"></span><br><span class="line">launchctl load -w ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.mysql.plist</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;HomeBrew安装&quot;&gt;&lt;a href=&quot;#HomeBrew安装&quot; class=&quot;headerlink&quot; title=&quot;HomeBrew安装&quot;&gt;&lt;/a&gt;HomeBrew安装&lt;/h4&gt;&lt;p&gt;1、&lt;code&gt;homebrew&lt;/code&gt; 是 &lt;code&gt;macOS&lt;
      
    
    </summary>
    
    
      <category term="mac工具" scheme="https://jasondcq.github.io/categories/mac%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="mac工具" scheme="https://jasondcq.github.io/tags/mac%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs快速学习系列(三)  组件化开发</title>
    <link href="https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E4%B8%89-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E4%B8%89-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</id>
    <published>2020-04-13T11:41:00.000Z</published>
    <updated>2020-05-07T09:58:49.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="认识组件化"><a href="#认识组件化" class="headerlink" title="认识组件化"></a>认识组件化</h3><h4 id="什么是组件化？"><a href="#什么是组件化？" class="headerlink" title="什么是组件化？"></a>什么是组件化？</h4><p>如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展，但如果我们将一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了，这就是组件化的思想。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpnimg_1_1.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="Vue组件化思想"><a href="#Vue组件化思想" class="headerlink" title="Vue组件化思想"></a>Vue组件化思想</h4><p>组件化是Vue.js中的重要思想,它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用,任何的应用都会被抽象成一颗组件树</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpnimg_2.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>有了组件化的思想，我们在之后的开发中就要充分的利用它,尽可能的将页面拆分成一个个小的、可复用的组件,这样让我们的代码更加方便组织和管理，并且扩展性也更强。</p><h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><h4 id="注册组件的基本步骤"><a href="#注册组件的基本步骤" class="headerlink" title="注册组件的基本步骤"></a>注册组件的基本步骤</h4><ul><li>组件的使用分成三个步骤<br>1、创建组件构造器<br>2、注册组件<br>3、使用组件</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_3.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>我们来看看通过代码如何注册组件，和直接使用一个<code>div</code>看起来并没有什么区别，但是我们可以设想，如果很多地方都要显示这样的信息，我们是不是就可以直接使用<code>&lt;my-cpn&gt;&lt;/my-cpn&gt;</code>来完成呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_4.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="注册组件步骤解析"><a href="#注册组件步骤解析" class="headerlink" title="注册组件步骤解析"></a>注册组件步骤解析</h4><p>这里的步骤都代表什么含义呢？</p><p>1、Vue.extend()：</p><ul><li>调用Vue.extend()创建的是一个组件构造器</li><li>通常在创建组件构造器时，传入template代表我们自定义组件的模板</li><li>该模板就是在使用到组件的地方，要显示的HTML代码</li><li>事实上，这种写法在Vue2.x的文档中几乎已经看不到了，它会直接使用下面我们会讲到的语法糖，但是在很多资料还是会提到这种方式，而且这种方式是学习后面方式的基础</li></ul><p>2、Vue.component()：</p><ul><li>调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称</li><li>所以需要传递两个参数：1、注册组件的标签名 2、组件构造器</li></ul><p>3、组件必须挂载在某个Vue实例下，否则它不会生效</p><ul><li>我们来看下面我使用了三次<my-cpn></my-cpn></li><li>而第三次其实并没有生效</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_5.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a>全局组件和局部组件</h4><ul><li>当我们通过调用Vue.component()注册组件时，组件的注册是全局的，这意味着该组件可以在任意Vue示例下使用。</li><li>如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_6.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_7.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="父组件和子组件"><a href="#父组件和子组件" class="headerlink" title="父组件和子组件"></a>父组件和子组件</h4><p>1、在前面我们看到了组件树</p><ul><li>组件和组件之间存在层级关系</li><li>而其中一种非常重要的关系就是父子组件的关系</li></ul><p>2、我们来看通过代码如何组成的这种层级关系:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_8.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>3、父子组件错误用法：以子标签的形式在Vue实例中使用</p><ul><li>因为当子组件注册到父组件的components时，Vue会编译好父组件的模块</li><li>该模板的内容已经决定了父组件将要渲染的HTML（相当于父组件中已经有了子组件中的内容了）</li><li><child-cpn></child-cpn>是只能在父组件中被识别的</li><li>类似这种用法，<child-cpn></child-cpn>是会被浏览器忽略的</li></ul><h4 id="注册组件语法糖"><a href="#注册组件语法糖" class="headerlink" title="注册组件语法糖"></a>注册组件语法糖</h4><p>1、在上面注册组件的方式，可能会有些繁琐</p><ul><li>Vue为了简化这个过程，提供了注册的语法糖</li><li>主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替</li></ul><p>2、语法糖注册全局组件和局部组件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_9.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_10.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="模板的分离写法"><a href="#模板的分离写法" class="headerlink" title="模板的分离写法"></a>模板的分离写法</h4><p>1、 刚才，我们通过语法糖简化了Vue组件的注册过程，另外还有一个地方的写法比较麻烦，就是template模块写法<br>2、如果我们能将其中的HTML分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰<br>3、vue提供了两种方案来定义HTML模块内容</p><ul><li>使用<code>&lt;script&gt;</code>标签</li><li>使用<code>&lt;template&gt;</code>标签</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_11.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_12.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="组件数据存放"><a href="#组件数据存放" class="headerlink" title="组件数据存放"></a>组件数据存放</h3><h4 id="组件可以访问Vue实例数据吗"><a href="#组件可以访问Vue实例数据吗" class="headerlink" title="组件可以访问Vue实例数据吗?"></a>组件可以访问Vue实例数据吗?</h4><p>1、组件是一个单独功能模块的封装：</p><ul><li>这个模块有属于自己的HTML模板，也应该有属性自己的数据data</li></ul><p>2、组件中的数据是保存在哪里呢？顶层的Vue实例中吗？</p><ul><li>我们先来测试一下，组件中能不能直接访问Vue实例中的data</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_13.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><ul><li>我们发现不能访问，而且即使可以访问，如果将所有的数据都放在Vue实例中，Vue实例就会变的非常臃肿</li><li>结论：Vue组件应该有自己保存数据的地方</li></ul><h4 id="组件数据的存放"><a href="#组件数据的存放" class="headerlink" title="组件数据的存放"></a>组件数据的存放</h4><p>1、组件自己的数据存放在哪里呢?</p><ul><li>组件对象也有一个data属性(也可以有methods等属性，下面我们有用到)</li><li>只是这个data属性必须是一个函数</li><li>而且这个函数返回一个对象，对象内部保存着数据</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_14.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="为什么是一个函数呢"><a href="#为什么是一个函数呢" class="headerlink" title="为什么是一个函数呢?"></a>为什么是一个函数呢?</h4><p>1、为什么data在组件中必须是一个函数呢?</p><ul><li>首先，如果不是一个函数，Vue直接就会报错</li><li>其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_15.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><h4 id="props基本用法"><a href="#props基本用法" class="headerlink" title="props基本用法"></a>props基本用法</h4><p>1、在组件中，使用选项props来声明需要从父级接收到的数据<br>2、props的值有两种方式：</p><ul><li>方式一：字符串数组，数组中的字符串就是传递时的名称</li><li>方式二：对象，对象可以设置传递时的类型，也可以设置默认值等</li></ul><p>3、我们先来看一个最简单的props传递</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_16.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="props数据验证"><a href="#props数据验证" class="headerlink" title="props数据验证"></a>props数据验证</h4><p>1、在前面，我们的props选项是使用一个数组<br>2、我们说过，除了数组之外，我们也可以使用对象，当需要对props进行类型等验证时，就需要对象写法了<br>3、验证都支持哪些数据类型呢？</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Date</li><li>Function</li><li>Symbol</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_17.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="子级向父级传递"><a href="#子级向父级传递" class="headerlink" title="子级向父级传递"></a>子级向父级传递</h3><h4 id="子级向父级传递-1"><a href="#子级向父级传递-1" class="headerlink" title="子级向父级传递"></a>子级向父级传递</h4><p>1、props用于父组件向子组件传递数据，还有一种比较常见的是子组件传递数据或事件到父组件中<br>2、我们应该如何处理呢？这个时候，我们需要使用自定义事件来完成<br>3、什么时候需要自定义事件呢？</p><ul><li>当子组件需要向父组件传递数据时，就要用到自定义事件了</li><li>我们之前学习的v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件</li></ul><p>4、自定义事件的流程</p><ul><li>在子组件中，通过$emit()来触发事件</li><li>在父组件中，通过v-on来监听子组件事件</li></ul><p>5、我们来看一个简单的例子</p><ul><li>我们之前做过一个两个按钮+1和-1，点击后修改counter</li><li>我们整个操作的过程还是在子组件中完成，但是之后的展示交给父组件</li><li>这样，我们就需要将子组件中的counter，传给父组件的某个属性，比如total</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_18.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="父子组件的访问"><a href="#父子组件的访问" class="headerlink" title="父子组件的访问"></a>父子组件的访问</h3><h4 id="父子组件的访问方式：-children"><a href="#父子组件的访问方式：-children" class="headerlink" title="父子组件的访问方式： $children"></a>父子组件的访问方式： $children</h4><p>1、有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件</p><ul><li>父组件访问子组件：使用$children或$refs</li><li>子组件访问父组件：使用$parent</li></ul><p>2、我们先来看下$children的访问</p><ul><li>this.$children是一个数组类型，它包含所有子组件对象</li><li>我们这里通过一个遍历，取出所有子组件的message状态</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_19.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="父子组件的访问方式：-refs"><a href="#父子组件的访问方式：-refs" class="headerlink" title="父子组件的访问方式： $refs"></a>父子组件的访问方式： $refs</h4><p>1、$children的缺陷：</p><ul><li>通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值</li><li>但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化</li><li>有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs</li></ul><p>2、$refs的使用：</p><ul><li>$refs和ref指令通常是一起使用的</li><li>首先，我们通过ref给某一个子组件绑定一个特定的ID</li><li>其次，通过this.$refs.ID就可以访问到该组件了</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_20.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_21.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h3><h4 id="为什么使用slot"><a href="#为什么使用slot" class="headerlink" title="为什么使用slot"></a>为什么使用slot</h4><p>1、slot翻译为插槽</p><ul><li>在生活中很多地方都有插槽，电脑的USB插槽，插板当中的电源插槽</li><li>插槽的目的是让我们原来的设备具备更多的扩展性</li><li>比如电脑的USB我们可以插入U盘、硬盘、手机、音响、键盘、鼠标等等</li></ul><p>2、组件的插槽</p><ul><li>组件的插槽也是为了让我们封装的组件更加具有扩展性</li><li>让使用者可以决定组件内部的一些内容到底展示什么</li></ul><h4 id="如何封装这类组件呢？slot"><a href="#如何封装这类组件呢？slot" class="headerlink" title="如何封装这类组件呢？slot"></a>如何封装这类组件呢？slot</h4><p>1、如何去封装这类的组件呢？</p><ul><li>它们也很多区别，但是也有很多共性</li><li>如果，我们每一个单独去封装一个组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封装</li><li>但是，如果我们封装成一个，好像也不合理：有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字，等等</li></ul><p>2、如何封装合适呢？抽取共性，保留不同</p><ul><li>最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽</li><li>一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容</li><li>是搜索框，还是文字，还是菜单。由调用者自己来决定</li></ul><p>3、这就是为什么我们要学习组件中的插槽slot的原因</p><h4 id="slot基本使用"><a href="#slot基本使用" class="headerlink" title="slot基本使用"></a>slot基本使用</h4><p>1、了解了为什么用<code>slot</code>，我们再来谈谈如何使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 在子组件中，使用特殊的元素&#96;&#96;&#96;&lt;slot&gt;&#96;&#96;&#96;就可以为子组件开启一个插槽</span><br><span class="line">* 该插槽插入什么内容取决于父组件如何使用</span><br><span class="line"></span><br><span class="line">2、我们通过一个简单的例子，来给子组件定义一个插槽</span><br><span class="line"></span><br><span class="line">* 插槽&#96;&#96;&#96;&lt;slot&gt;&#96;&#96;&#96;中的内容表示，如果没有在该组件中插入任何其他内容，就默认显示该内容</span><br><span class="line">* 有了这个插槽后，父组件如何使用呢？</span><br><span class="line"></span><br><span class="line"> ![avatar](http:&#x2F;&#x2F;blog.dcq.kuryun.cn&#x2F;vue&#x2F;img&#x2F;cpn&#x2F;img_22.png)</span><br><span class="line"></span><br><span class="line">![avatar](http:&#x2F;&#x2F;blog.dcq.kuryun.cn&#x2F;vue&#x2F;img&#x2F;cpn&#x2F;img_23.png)</span><br><span class="line"></span><br><span class="line">#### 具名插槽slot</span><br><span class="line"></span><br><span class="line">1、当子组件的功能复杂时，子组件的插槽可能并非是一个</span><br><span class="line"></span><br><span class="line">* 比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边</span><br><span class="line">* 那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？</span><br><span class="line">* 这个时候，我们就需要给插槽起一个名字</span><br><span class="line"></span><br><span class="line">2、如何使用具名插槽呢？</span><br><span class="line"></span><br><span class="line">* 非常简单，只要给&#96;&#96;&#96;slot&#96;&#96;&#96;元素一个&#96;&#96;&#96;name&#96;&#96;&#96;属性即可</span><br><span class="line">* 代码&#96;&#96;&#96;&lt;slot name&#x3D;&#39;myslot&#39;&gt;&lt;&#x2F;slot&gt;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_24.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_25.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="作用域插槽：准备"><a href="#作用域插槽：准备" class="headerlink" title="作用域插槽：准备"></a>作用域插槽：准备</h4><p>1、作用域插槽是slot一个比较难理解的点，而且官方文档说的又有点不清晰<br>2、这里，我们用一句话对其做一个总结，然后我们在后续的案例中来体会</p><ul><li>父组件替换插槽的标签，但是内容由子组件来提供</li></ul><p>3、我们先提一个需求</p><ul><li>子组件中包括一组数据，比如：<code>pLanguages: [&#39;JavaScript&#39;, &#39;Python&#39;, &#39;Swift&#39;, &#39;Go&#39;, &#39;C++&#39;]</code></li><li>需要在多个界面进行展示</li><li>某些界面是以水平方向一一展示的</li><li>某些界面是以列表形式展示的</li><li>某些界面直接展示一个数组</li><li>内容在子组件，希望父组件告诉我们如何展示，怎么办呢？</li><li>利用<code>slot</code>作用域插槽就可以了</li></ul><p>4、我们来看看子组件的定义：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_26.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="作用域插槽：使用"><a href="#作用域插槽：使用" class="headerlink" title="作用域插槽：使用"></a>作用域插槽：使用</h4><p>1、在父组件使用我们的子组件时，从子组件中拿到数据</p><ul><li>我们通过<code>&lt;template slot-scope=&quot;slotProps&quot;&gt;</code>获取到<code>slotProps</code>属性</li><li>在通过<code>slotProps.data</code>就可以获取到刚才我们传入的<code>data</code>了</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/cpn/img_27.jpg" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;认识组件化&quot;&gt;&lt;a href=&quot;#认识组件化&quot; class=&quot;headerlink&quot; title=&quot;认识组件化&quot;&gt;&lt;/a&gt;认识组件化&lt;/h3&gt;&lt;h4 id=&quot;什么是组件化？&quot;&gt;&lt;a href=&quot;#什么是组件化？&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Vuejs快速学习系列" scheme="https://jasondcq.github.io/categories/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vuejs" scheme="https://jasondcq.github.io/tags/Vuejs/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs快速学习系列(二)  基础语法</title>
    <link href="https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E4%BA%8C-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E4%BA%8C-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-04-13T08:18:00.000Z</published>
    <updated>2020-04-13T13:40:56.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="插值操作"><a href="#插值操作" class="headerlink" title="插值操作"></a>插值操作</h3><p>如何将<code>data</code>中的文本数据，插入到<code>html</code>中呢？可以通过<code>Mustache</code>语法(也就是双大括号),我们可以像下面这样来使用，并且数据是响应式的:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_7.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h4><p>在某些情况下，我们可能不希望界面随意的跟随改变,这个时候，我们就可以使用一个Vue的指令,<code>v-once</code>该指令后面不需要跟任何表达式,该指令表示元素和组件只渲染一次，不会随着数据的改变而改变,代码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_8.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h4><p>当我们从服务器请求到的数据本身就是一个<code>html</code>代码，如果我们直接通过<code>Mustache</code>来输出，会将<code>html</code>代码也一起输出,但是我们可能希望的是按照<code>html</code>格式进行解析，并且显示对应的内容,这时候就可以使用<code>v-html</code>指令, 该指令后面往往会跟上一个string类型, 会将string的html解析出来并且进行渲染。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_9.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h4><p>指令<code>v-text</code>作用和<code>Mustache</code>比较相似,都是用于将数据显示在界面中,<code>v-text</code>通常情况下，接受一个<code>string</code>类型.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_10.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h4><p>指令<code>v-pre</code>用于跳过这个元素和它子元素的编译过程，用于显示原本的<code>Mustache</code>语法,比如下面的代码：第一个<code>h2</code>元素中的内容会被编译解析出来对应的内容；第二个<code>h2</code>元素中会直接显示<code></code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_11.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h3><p>前面我们学习的指令主要作用是将值插入到我们模板的内容当中，但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定，比如动态绑定<code>a</code>元素的<code>href</code>属性, 比如动态绑定<code>img</code>元素的<code>src</code>属性,这个时候，我们可以使用<code>v-bind</code>指令。</p><h4 id="v-bind基础"><a href="#v-bind基础" class="headerlink" title="v-bind基础"></a>v-bind基础</h4><p>指令<code>v-bind</code>用于绑定一个或多个属性值，或者向另一个组件传递<code>props</code>值，在开发中，有哪些属性需要动态进行绑定呢？还是有很多的，比如图片的链接<code>src</code>、网站的链接<code>href</code>、动态绑定一些类、样式等等。通过Vue实例中的<code>data</code>绑定元素的<code>src</code>和<code>href</code>，代码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_12.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-bind语法糖"><a href="#v-bind语法糖" class="headerlink" title="v-bind语法糖"></a>v-bind语法糖</h4><p>指令<code>v-bind</code>有一个对应的语法糖，也就是简写方式,在开发中，我们通常会使用语法糖的形式，因为这样更加简洁,简写方式如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_13.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-bind绑定class"><a href="#v-bind绑定class" class="headerlink" title="v-bind绑定class"></a>v-bind绑定class</h4><p>很多时候，我们希望动态的来切换<code>class</code>，比如:当数据为某个状态时，字体显示红色,当数据另一个状态时，字体显示黑色。绑定class有两种方式：</p><ul><li>对象语法</li><li>数组语法</li></ul><p>1、对象语法的含义是:class后面跟的是一个对象，有下面这些用法：<br>用法一：直接通过{}绑定一个类<br>例：<code>html&lt;h2 :class=&quot;{&#39;active&#39;: isActive}&quot;&gt;Hello World&lt;/h2&gt;</code></p><p>用法二：也可以通过判断，传入多个值<br>例：<code>&lt;h2 :class=&quot;{&#39;active&#39;: isActive, &#39;line&#39;: isLine}&quot;&gt;Hello World&lt;/h2&gt;</code></p><p>用法三：和普通的类同时存在，并不冲突<br>注：如果isActive和isLine都为true，那么会有title/active/line三个类<br>例：<code>&lt;h2 class=&quot;title&quot; :class=&quot;{&#39;active&#39;: isActive, &#39;line&#39;: isLine}&quot;&gt;Hello World&lt;/h2&gt;</code></p><p>用法四：如果过于复杂，可以放在一个methods或者computed中<br>注：classes是一个计算属性<br>例：<code>&lt;h2 class=&quot;title&quot; :class=&quot;classes&quot;&gt;Hello World&lt;/h2&gt;</code></p><p>2、数组语法的含义是:class后面跟的是一个数组，有下面这些用法：<br>用法一：直接通过{}绑定一个类<br>例：<code>&lt;h2 :class=&quot;[&#39;active&#39;]&quot;&gt;Hello World&lt;/h2&gt;</code></p><p>用法二：也可以传入多个值<br>例：<code>&lt;h2 :class=“[‘active’, &#39;line&#39;]&quot;&gt;Hello World&lt;/h2&gt;</code></p><p>用法三：和普通的类同时存在，并不冲突<br>注：会有title/active/line三个类<br>例：<code>&lt;h2 class=&quot;title&quot; :class=“[‘active’, &#39;line&#39;]&quot;&gt;Hello World&lt;/h2&gt;</code></p><h4 id="v-bind绑定style"><a href="#v-bind绑定style" class="headerlink" title="v-bind绑定style"></a>v-bind绑定style</h4><p>我们可以利用<code>v-bind:style</code>来绑定一些CSS内联样式,在写CSS属性名的时候，比如<code>font-size</code>,我们可以使用驼峰式 (camelCase)  <code>fontSize</code>,或短横线分隔 (kebab-case，记得用单引号括起来) <code>‘font-size’</code>,绑定class有两种方式:</p><ul><li><p>对象语法<br>  1、代码<code>:style=&quot;{color: currentColor, fontSize: fontSize + &#39;px&#39;}&quot;</code>,style后面跟的是一个对象类型；<br>  2、对象的key是CSS属性名称<br>  3、对象的value是具体赋的值，值可以来自于data中的属性</p></li><li><p>数组语法<br>  1、代码<code>&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;</code>,style后面跟的是一个数组类型多个值以，分割即可。</p></li></ul><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><h4 id="什么是计算属性？"><a href="#什么是计算属性？" class="headerlink" title="什么是计算属性？"></a>什么是计算属性？</h4><p>在模板中可以直接通过插值语法显示一些<code>data</code>中的数据，但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示，比如我们有<code>firstName</code>和<code>lastName</code>两个变量，我们需要显示完整的名称，但是如果多个地方都需要显示完整的名称，我们就需要写多个<code> </code>,这时候我们可以将上面的代码换成计算属性。计算属性是写在实例的<code>computed</code>选项中，如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_14.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_15.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>计算属性中也可以进行一些更加复杂的操作，比如下面的例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_16.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="计算属性的setter和getter"><a href="#计算属性的setter和getter" class="headerlink" title="计算属性的setter和getter"></a>计算属性的setter和getter</h4><p>每个计算属性都包含一个<code>getter</code>和一个<code>setter</code>, 在上面的例子中，我们只是使用<code>getter</code>来读取,在某些情况下，你也可以提供一个<code>setter</code>方法（不常用）,在需要写<code>setter</code>的时候，代码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_17.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="计算属性的缓存"><a href="#计算属性的缓存" class="headerlink" title="计算属性的缓存"></a>计算属性的缓存</h4><p>我们可能会考虑这样的一个问题, <code>methods</code>和<code>computed</code>看起来都可以实现我们的功能,那么为什么还要多一个计算属性这个东西呢？原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_18.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_19.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>在前端开发中，我们需要经常和用户交互，这个时候，我们就必须监听用户发生交互的时间，比如点击、拖拽、键盘事件等等。在Vue中如何监听事件呢？使用<code>v-on</code>指令</p><h4 id="v-on基础"><a href="#v-on基础" class="headerlink" title="v-on基础"></a>v-on基础</h4><p>我们用一个监听按钮的点击事件，来简单看看<code>v-on</code>的使用,下面的代码中，我们使用了<code>v-on:click=&quot;counter++”</code>,另外，我们可以将事件指向一个在<code>methods</code>中定义的函数</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_20.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_21.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>指令<code>v-on</code>也有对应的语法糖<code>v-on:click</code>可以写成<code>@click</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_22.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-on参数"><a href="#v-on参数" class="headerlink" title="v-on参数"></a>v-on参数</h4><p>当通过<code>methods</code>中定义方法，以供<code>@click</code>调用时，需要注意参数问题,情况一如果该方法不需要额外参数，那么方法后的()可以不添加,但是注意如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去,情况二如果需要同时传入某个参数，同时需要<code>event</code>时，可以通过<code>$event</code>传入事件:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_23.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_24.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-on修饰符"><a href="#v-on修饰符" class="headerlink" title="v-on修饰符"></a>v-on修饰符</h4><p>在某些情况下，我们拿到<code>event</code>的目的可能是进行一些事件处理,Vue提供了修饰符来帮助我们方便的处理一些事件<code>.stop</code> - 调用 <code>event.stopPropagation()</code>,<code>.prevent</code> - 调用 <code>event.preventDefault()</code>, .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调,<code>.native</code> - 监听组件根元素的原生事件,<code>.once</code> - 只触发一次回调</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_25.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="v-if、v-else-if、v-else"><a href="#v-if、v-else-if、v-else" class="headerlink" title="v-if、v-else-if、v-else"></a>v-if、v-else-if、v-else</h4><p>指令<code>v-if、v-else-if、v-else</code>这三个指令与JavaScript的条件语句<code>if、else、else if</code>类似,Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件,简单的案例演示:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_26.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_27.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>原理<code>v-if</code>后面的条件为<code>false</code>时，对应的元素以及其子元素不会渲染,也就是根本没有不会有对应的标签出现在DOM中。</p><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>指令<code>v-show</code>的用法和<code>v-if</code>非常相似，也用于决定一个元素是否渲染,v-if和v-show都可以决定一个元素是否渲染，那么开发中我们如何选择呢？<code>v-if</code>当条件为<code>false</code>时，压根不会有对应的元素在DOM中,<code>v-show</code>当条件为<code>false</code>时，仅仅是将元素的<code>display</code>属性设置为<code>none</code>而已。开发中如何选择呢？当需要在显示与隐藏之间切片很频繁时，使用<code>v-show</code>,当只有一次切换时，通过使用<code>v-if</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_30.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><h4 id="v-for遍历数组"><a href="#v-for遍历数组" class="headerlink" title="v-for遍历数组"></a>v-for遍历数组</h4><p>当我们有一组数据需要进行渲染时，我们就可以使用<code>v-for</code>来完成,<code>v-for</code>的语法类似于<code>JavaScript</code>中的<code>for</code>循环,格式如下：<code>item in items</code>的形式。<br>如果在遍历的过程中不需要使用索引值<code>-for=&quot;movie in movies&quot;</code>依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie,如果在遍历的过程中，我们需要拿到元素在数组中的索引值呢？语法格式：<code>v-for=(item, index) in items</code>其中的<code>index</code>就代表了取出的<code>item</code>在原数组的索引值.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_31.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-for遍历对象"><a href="#v-for遍历对象" class="headerlink" title="v-for遍历对象"></a>v-for遍历对象</h4><p>指令<code>v-for</code>可以用户遍历对象,比如某个对象中存储着你的个人信息，我们希望以列表的形式显示出来</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_32.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="组件的key属性"><a href="#组件的key属性" class="headerlink" title="组件的key属性"></a>组件的key属性</h4><p>官方推荐我们在使用<code>v-for</code>时，给对应的元素或组件添加上一个<code>:key</code>属性,<code>key</code>的作用主要是为了高效的更新虚拟DOM</p><h4 id="检测数组更新"><a href="#检测数组更新" class="headerlink" title="检测数组更新"></a>检测数组更新</h4><p>因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新,Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新。<code>push()、pop()、shift()、unshift()、splice()、sort()、reverse()</code>；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_33.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><h4 id="表单绑定v-model"><a href="#表单绑定v-model" class="headerlink" title="表单绑定v-model"></a>表单绑定v-model</h4><p>表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单,Vue中使用<code>v-model</code>指令来实现表单元素和数据的双向绑定。<br>当我们在输入框输入内容时，因为<code>input</code>中的<code>v-model</code>绑定了<code>message</code>，所以会实时将输入的内容传递给<code>message</code>，<code>message</code>发生改变,当<code>message</code>发生改变时，因为上面我们使用Mustache语法，将<code>message</code>的值插入到DOM中，所以DOM会发生响应的改变,所以，通过<code>v-model</code>实现了双向的绑定</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_34.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>当然，我们也可以将<code>v-model</code>用于<code>textarea</code>元素</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_35.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h4><p>指令<code>v-model</code>其实是一个语法糖，它的背后本质上是包含两个操作。<br>1.<code>v-bind</code>绑定一个<code>value</code>属性<br>2.<code>v-on</code>指令给当前元素绑定<code>input</code>事件<br>也就是说下面的代码：等同于下面的代码:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_36.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-model：radio"><a href="#v-model：radio" class="headerlink" title="v-model：radio"></a>v-model：radio</h4><p>当存在多个单选框时</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_37.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-model：checkbox"><a href="#v-model：checkbox" class="headerlink" title="v-model：checkbox"></a>v-model：checkbox</h4><p>复选框分为两种情况：单个勾选框和多个勾选框</p><ul><li>单个勾选框<br>1、<code>v-model</code>即为布尔值<br>2、此时<code>input</code>的<code>value</code>并不影响<code>v-model</code>的值</li><li>多个复选框<br>1、当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组<br>2、当选中某一个时，就会将<code>input</code>的<code>value</code>添加到数组中</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_38.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_39.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="v-model：select"><a href="#v-model：select" class="headerlink" title="v-model：select"></a>v-model：select</h4><p>和checkbox一样，select也分单选和多选两种情况</p><ul><li>单选：只能选中一个值<br>1、<code>v-model</code>绑定的是一个值<br>2、当我们选中<code>option</code>中的一个时，会将它对应的<code>value</code>赋值到<code>mySelect</code>中</li><li>多选：可以选中多个值<br>1、<code>v-model</code>绑定的是一个数组<br>2、当选中多个值时，就会将选中的<code>option</code>对应的<code>value</code>添加到数组<code>mySelects</code>中</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_40.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_41.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_42.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;插值操作&quot;&gt;&lt;a href=&quot;#插值操作&quot; class=&quot;headerlink&quot; title=&quot;插值操作&quot;&gt;&lt;/a&gt;插值操作&lt;/h3&gt;&lt;p&gt;如何将&lt;code&gt;data&lt;/code&gt;中的文本数据，插入到&lt;code&gt;html&lt;/code&gt;中呢？可以通过&lt;code&gt;Mu
      
    
    </summary>
    
    
      <category term="Vuejs快速学习系列" scheme="https://jasondcq.github.io/categories/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vuejs" scheme="https://jasondcq.github.io/tags/Vuejs/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs快速学习系列(一)   Vue初体验与MVVM</title>
    <link href="https://jasondcq.github.io/%E8%AE%A4%E8%AF%86Vuejs/"/>
    <id>https://jasondcq.github.io/%E8%AE%A4%E8%AF%86Vuejs/</id>
    <published>2020-04-11T08:46:00.000Z</published>
    <updated>2020-04-13T13:40:56.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单认识Vuejs"><a href="#简单认识Vuejs" class="headerlink" title="简单认识Vuejs"></a>简单认识Vuejs</h3><p>Vue读作/vju:/是一个渐进式的框架，这意味着你可以将Vue作为你应用的一部分嵌入其中，也可以使用Vue核心库及其生态系统，Core+Vue-router+Vuex实现各种各样的业务需求，带来更丰富的交互体验。</p><ul><li>Vue的特点</li></ul><p>1.解耦视图和数据；<br>2.可复用组件；<br>3.前端路由技术；<br>4.状态管理；<br>5.虚拟DOM；</p><h3 id="Hello-Vuejs"><a href="#Hello-Vuejs" class="headerlink" title="Hello Vuejs"></a>Hello Vuejs</h3><p>我们来编写我们的第一个Vue程序，体验一下Vue的响应式，截取代码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_1.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>代码做了什么事情？我们来阅读JavaScript代码，会发现创建了一个Vue对象,在创建Vue对象的时候，传入了一些、<code>options：{}</code>，<code>{}</code>中包含了el属性：该属性决定了这个Vue对象挂载到哪一个元素上，很明显，我们这里是挂载到了id为app的元素上,<code>{}</code>中包含了data属性,该属性中通常会存储一些数据,这些数据可以是我们直接定义出来的，比如像上面这样;也可能是来自网络，从服务器加载的。当浏览器执行到10~13行代码显然出对应的HTML，执行第16行代码创建Vue实例，并且对原HTML进行解析和修改。</p><h3 id="Vue列表显示"><a href="#Vue列表显示" class="headerlink" title="Vue列表显示"></a>Vue列表显示</h3><p>现在，我们来展示一个更加复杂的数据：数据列表；当我们现在从服务器请求过来一个列表，希望展示到<code>html</code>中，截取代码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_2.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_3.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><p>在<code>html</code>代码中，使用<code>v-for</code>指令,是不是变得So Easy，我们再也不需要在JavaScript代码中完成DOM的拼接相关操作了。而且，它还是响应式的，当我们数组中的数据发生改变时，界面会自动改变。</p><h3 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h3><p>我们来看Vue的MVVM，图示如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_4.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><blockquote><p>View层：</p><blockquote><p>视图层<br>在我们前端开发中，通常就是DOM层<br>主要的作用是给用户展示各种信息</p></blockquote></blockquote><blockquote><p>Model层:</p><blockquote><p>数据层<br>数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据</p></blockquote></blockquote><blockquote><p>VueModel层：</p><blockquote><p>视图模型层<br>视图模型层是View和Model沟通的桥梁<br>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中<br>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data</p></blockquote></blockquote><h3 id="Vue的options"><a href="#Vue的options" class="headerlink" title="Vue的options"></a>Vue的options</h3><p>我们在创建Vue实例的时候，传入了一个对象<code>options</code>，这个options中可以包含哪些选项呢？一般开发中主要掌握以下几点：</p><ul><li>el：<br>  1、类型：string | HTMLElement<br> 2、作用：决定之后Vue实例会管理哪一个DOM</li><li>data：<br> 1、类型：Object | Function （组件当中data必须是一个函数）<br> 2、作用：Vue实例对应的数据对象</li><li>methods：<br> 1、类型：{ [key: string]: Function }<br> 2、作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用</li></ul><h3 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h3><p>生命周期流程图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_5.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.dcq.kuryun.cn/vue/img/img_6.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单认识Vuejs&quot;&gt;&lt;a href=&quot;#简单认识Vuejs&quot; class=&quot;headerlink&quot; title=&quot;简单认识Vuejs&quot;&gt;&lt;/a&gt;简单认识Vuejs&lt;/h3&gt;&lt;p&gt;Vue读作/vju:/是一个渐进式的框架，这意味着你可以将Vue作为你应用的一部分嵌
      
    
    </summary>
    
    
      <category term="Vuejs快速学习系列" scheme="https://jasondcq.github.io/categories/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Vuejs" scheme="https://jasondcq.github.io/tags/Vuejs/"/>
    
  </entry>
  
</feed>
