{"meta":{"title":"Jason's Blog","subtitle":"丁昌乾_技术博客","description":"丁昌乾的博客。选择大于努力，格局决定结局","author":"JasonD","url":"https://jasondcq.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-04-09T15:13:06.000Z","updated":"2020-04-11T06:53:03.736Z","comments":false,"path":"tags/index.html","permalink":"https://jasondcq.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-04-09T15:14:16.000Z","updated":"2020-04-09T15:14:54.966Z","comments":false,"path":"categories/index.html","permalink":"https://jasondcq.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac修复'CoreFoundation/CoreFoundation.h' file not found问题","slug":"Mac修复-CoreFoundation-CoreFoundation-h-file-not-found问题","date":"2020-05-03T12:54:00.000Z","updated":"2020-05-03T12:58:15.567Z","comments":true,"path":"Mac修复-CoreFoundation-CoreFoundation-h-file-not-found问题/","link":"","permalink":"https://jasondcq.github.io/Mac%E4%BF%AE%E5%A4%8D-CoreFoundation-CoreFoundation-h-file-not-found%E9%97%AE%E9%A2%98/","excerpt":"","text":"修复’CoreFoundation/CoreFoundation.h’ file not found在macOS 10.15下/System/Library/Frameworks/缺少很多头/库文件，会导致很多软件编译失败。比如:CoreFoundation（找不到#include &lt;CoreFoundation/CoreFoundation.h&gt;）解决方案如下： $ sudo mount -uw / # 根目录挂载为可读写，否则无法在/usr/下建立文件，本修改重启前有效。$ sudo ln -s &quot;$(xcrun --show-sdk-path)/usr/include&quot; /usr/include $ export SDKROOT=&quot;$(xcrun --show-sdk-path)&quot; # 设置环境变量$ echo &quot;export SDKROOT=\\&quot;\\$(xcrun --show-sdk-path)\\&quot;&quot; &gt;&gt; ~/.bash_profile # zsh的自行搞定$ sudo DevToolsSecurity -enable # 将系统置于开发模式","categories":[{"name":"mac工具","slug":"mac工具","permalink":"https://jasondcq.github.io/categories/mac%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"mac工具","slug":"mac工具","permalink":"https://jasondcq.github.io/tags/mac%E5%B7%A5%E5%85%B7/"}],"author":"JasonD"},{"title":"Mac使用brew安装memcached、redis、mysql","slug":"Mac使用brew安装memcached","date":"2020-04-24T06:13:00.000Z","updated":"2020-05-03T13:09:52.928Z","comments":true,"path":"Mac使用brew安装memcached/","link":"","permalink":"https://jasondcq.github.io/Mac%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85memcached/","excerpt":"","text":"HomeBrew安装1、homebrew 是 macOS 缺失的软件包管理器,譬如可以下载 mysql、redis、wget 等等.操作系统：macOS High Sierra Version 10.14.52、Homebrew 会将软件包安装到独立目录,并将其文件软链接至 /usr/local . Homebrew 不会将文件安装到它本身目录之外,所以您可将 Homebrew 安装到任意位置.3、/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;4、官方网站https://brew.sh/ HomeBrew的基本使用方法：1234567brew search ** &#x2F;&#x2F;查找某个软件包brew list &#x2F;&#x2F;列出已经安装的软件的包brew install ** &#x2F;&#x2F;安装某个软件包,默认安装的是稳定版本brew uninstall **&#x2F;&#x2F;卸载某个软件的包brew upgrade ** &#x2F;&#x2F;更新某个软件包brew info ** &#x2F;&#x2F;查看指定软件包的说明brew cache clean &#x2F;&#x2F;清理缓存 memcached安装1、使用命令brew info memcached检查是否已安装memcached及其依赖包情况 avatar 2、如上图所示，memcached的依赖包为libevent，如果未安装libevent（会打个红色的X），则需要首先查看libevent安装的依赖包，检查libevent的依赖包是否安装，使用命令brew info libevent: avatar 3、未安装的依赖会打一个红色的X，安装打X依赖 12brew install doxygenbrew install libtool 4、依赖包安装完后 12brew install libeventbrew install memcached 5、安装完成，启动服务 12345678&#x2F;&#x2F;启动brew services start memcached&#x2F;&#x2F;停止brew services stop memcached&#x2F;&#x2F;重启brew services restart memcached&#x2F;&#x2F;查看所有运行的服务brew services list redis安装1、安装包管理器最新版本brew install redis 2、安装指定版本brew install redis@4.0 3、/usr/local/etc 下修改redis.config找到daemonize no 改成yes以守护进程的方式启动配置环境变量echo ‘export PATH=”/usr/local/opt/redis@3.2/bin:$PATH”‘ &gt;&gt; ~/.zshrc 4、启动:brew services start redis或者使用redis-server /usr/local/etc/redis.conf启动 5、查看进程ps axu | grep redis 6、关闭redis-cli shutdown 7、杀死sudo pkill redis-server 安装 mysql1234brew updatebrew install mysqlbrew info mysql&#96; 运行 brew service start mysql 可以后台启动 mysql,运行 mysql.server start 前台启动 mysql(关闭控制台,服务停止),当安装完成之后需要进行一些设置。 设置密码需先启动 mysql 服务 mysql_secure_installation 设置完之后测试一下，连接mysql: mysql -u root -p 123456 配置自启动1234567mkdir -p ~&#x2F;Library&#x2F;LaunchAgentsln -sfv &#x2F;usr&#x2F;local&#x2F;opt&#x2F;mysql&#x2F;*.plist ~&#x2F;Library&#x2F;LaunchAgentsfind &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;mysql&#x2F; -name &quot;homebrew.mxcl.mysql.plist&quot; -exec cp &#123;&#125; ~&#x2F;Library&#x2F;LaunchAgents&#x2F; \\;launchctl load -w ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.mysql.plist","categories":[{"name":"mac工具","slug":"mac工具","permalink":"https://jasondcq.github.io/categories/mac%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"mac工具","slug":"mac工具","permalink":"https://jasondcq.github.io/tags/mac%E5%B7%A5%E5%85%B7/"}],"author":"JasonD"},{"title":"Vuejs快速学习系列(三)  组件化开发","slug":"Vuejs快速学习系列-三-组件化开发","date":"2020-04-13T11:41:00.000Z","updated":"2020-05-07T09:58:49.513Z","comments":true,"path":"Vuejs快速学习系列-三-组件化开发/","link":"","permalink":"https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E4%B8%89-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/","excerpt":"","text":"认识组件化什么是组件化？如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展，但如果我们将一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了，这就是组件化的思想。 avatar Vue组件化思想组件化是Vue.js中的重要思想,它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用,任何的应用都会被抽象成一颗组件树 avatar 有了组件化的思想，我们在之后的开发中就要充分的利用它,尽可能的将页面拆分成一个个小的、可复用的组件,这样让我们的代码更加方便组织和管理，并且扩展性也更强。 注册组件注册组件的基本步骤 组件的使用分成三个步骤1、创建组件构造器2、注册组件3、使用组件 avatar 我们来看看通过代码如何注册组件，和直接使用一个div看起来并没有什么区别，但是我们可以设想，如果很多地方都要显示这样的信息，我们是不是就可以直接使用&lt;my-cpn&gt;&lt;/my-cpn&gt;来完成呢？ avatar 注册组件步骤解析这里的步骤都代表什么含义呢？ 1、Vue.extend()： 调用Vue.extend()创建的是一个组件构造器 通常在创建组件构造器时，传入template代表我们自定义组件的模板 该模板就是在使用到组件的地方，要显示的HTML代码 事实上，这种写法在Vue2.x的文档中几乎已经看不到了，它会直接使用下面我们会讲到的语法糖，但是在很多资料还是会提到这种方式，而且这种方式是学习后面方式的基础 2、Vue.component()： 调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称 所以需要传递两个参数：1、注册组件的标签名 2、组件构造器 3、组件必须挂载在某个Vue实例下，否则它不会生效 我们来看下面我使用了三次 而第三次其实并没有生效 avatar 全局组件和局部组件 当我们通过调用Vue.component()注册组件时，组件的注册是全局的，这意味着该组件可以在任意Vue示例下使用。 如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件 avatar avatar 父组件和子组件1、在前面我们看到了组件树 组件和组件之间存在层级关系 而其中一种非常重要的关系就是父子组件的关系 2、我们来看通过代码如何组成的这种层级关系: avatar 3、父子组件错误用法：以子标签的形式在Vue实例中使用 因为当子组件注册到父组件的components时，Vue会编译好父组件的模块 该模板的内容已经决定了父组件将要渲染的HTML（相当于父组件中已经有了子组件中的内容了） 是只能在父组件中被识别的 类似这种用法，是会被浏览器忽略的 注册组件语法糖1、在上面注册组件的方式，可能会有些繁琐 Vue为了简化这个过程，提供了注册的语法糖 主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替 2、语法糖注册全局组件和局部组件 avatar avatar 模板的分离写法1、 刚才，我们通过语法糖简化了Vue组件的注册过程，另外还有一个地方的写法比较麻烦，就是template模块写法2、如果我们能将其中的HTML分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰3、vue提供了两种方案来定义HTML模块内容 使用&lt;script&gt;标签 使用&lt;template&gt;标签 avatar avatar 组件数据存放组件可以访问Vue实例数据吗?1、组件是一个单独功能模块的封装： 这个模块有属于自己的HTML模板，也应该有属性自己的数据data 2、组件中的数据是保存在哪里呢？顶层的Vue实例中吗？ 我们先来测试一下，组件中能不能直接访问Vue实例中的data avatar 我们发现不能访问，而且即使可以访问，如果将所有的数据都放在Vue实例中，Vue实例就会变的非常臃肿 结论：Vue组件应该有自己保存数据的地方 组件数据的存放1、组件自己的数据存放在哪里呢? 组件对象也有一个data属性(也可以有methods等属性，下面我们有用到) 只是这个data属性必须是一个函数 而且这个函数返回一个对象，对象内部保存着数据 avatar 为什么是一个函数呢?1、为什么data在组件中必须是一个函数呢? 首先，如果不是一个函数，Vue直接就会报错 其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响 avatar 父子组件通信props基本用法1、在组件中，使用选项props来声明需要从父级接收到的数据2、props的值有两种方式： 方式一：字符串数组，数组中的字符串就是传递时的名称 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等 3、我们先来看一个最简单的props传递 avatar props数据验证1、在前面，我们的props选项是使用一个数组2、我们说过，除了数组之外，我们也可以使用对象，当需要对props进行类型等验证时，就需要对象写法了3、验证都支持哪些数据类型呢？ String Number Boolean Array Object Date Function Symbol avatar 子级向父级传递子级向父级传递1、props用于父组件向子组件传递数据，还有一种比较常见的是子组件传递数据或事件到父组件中2、我们应该如何处理呢？这个时候，我们需要使用自定义事件来完成3、什么时候需要自定义事件呢？ 当子组件需要向父组件传递数据时，就要用到自定义事件了 我们之前学习的v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件 4、自定义事件的流程 在子组件中，通过$emit()来触发事件 在父组件中，通过v-on来监听子组件事件 5、我们来看一个简单的例子 我们之前做过一个两个按钮+1和-1，点击后修改counter 我们整个操作的过程还是在子组件中完成，但是之后的展示交给父组件 这样，我们就需要将子组件中的counter，传给父组件的某个属性，比如total avatar 父子组件的访问父子组件的访问方式： $children1、有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件 父组件访问子组件：使用$children或$refs 子组件访问父组件：使用$parent 2、我们先来看下$children的访问 this.$children是一个数组类型，它包含所有子组件对象 我们这里通过一个遍历，取出所有子组件的message状态 avatar 父子组件的访问方式： $refs1、$children的缺陷： 通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值 但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化 有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs 2、$refs的使用： $refs和ref指令通常是一起使用的 首先，我们通过ref给某一个子组件绑定一个特定的ID 其次，通过this.$refs.ID就可以访问到该组件了 avatar avatar 插槽slot为什么使用slot1、slot翻译为插槽 在生活中很多地方都有插槽，电脑的USB插槽，插板当中的电源插槽 插槽的目的是让我们原来的设备具备更多的扩展性 比如电脑的USB我们可以插入U盘、硬盘、手机、音响、键盘、鼠标等等 2、组件的插槽 组件的插槽也是为了让我们封装的组件更加具有扩展性 让使用者可以决定组件内部的一些内容到底展示什么 如何封装这类组件呢？slot1、如何去封装这类的组件呢？ 它们也很多区别，但是也有很多共性 如果，我们每一个单独去封装一个组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封装 但是，如果我们封装成一个，好像也不合理：有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字，等等 2、如何封装合适呢？抽取共性，保留不同 最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽 一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容 是搜索框，还是文字，还是菜单。由调用者自己来决定 3、这就是为什么我们要学习组件中的插槽slot的原因 slot基本使用1、了解了为什么用slot，我们再来谈谈如何使用 12345678910111213141516171819202122232425* 在子组件中，使用特殊的元素&#96;&#96;&#96;&lt;slot&gt;&#96;&#96;&#96;就可以为子组件开启一个插槽* 该插槽插入什么内容取决于父组件如何使用2、我们通过一个简单的例子，来给子组件定义一个插槽* 插槽&#96;&#96;&#96;&lt;slot&gt;&#96;&#96;&#96;中的内容表示，如果没有在该组件中插入任何其他内容，就默认显示该内容* 有了这个插槽后，父组件如何使用呢？ ![avatar](http:&#x2F;&#x2F;blog.dcq.kuryun.cn&#x2F;vue&#x2F;img&#x2F;cpn&#x2F;img_22.png)![avatar](http:&#x2F;&#x2F;blog.dcq.kuryun.cn&#x2F;vue&#x2F;img&#x2F;cpn&#x2F;img_23.png)#### 具名插槽slot1、当子组件的功能复杂时，子组件的插槽可能并非是一个* 比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边* 那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？* 这个时候，我们就需要给插槽起一个名字2、如何使用具名插槽呢？* 非常简单，只要给&#96;&#96;&#96;slot&#96;&#96;&#96;元素一个&#96;&#96;&#96;name&#96;&#96;&#96;属性即可* 代码&#96;&#96;&#96;&lt;slot name&#x3D;&#39;myslot&#39;&gt;&lt;&#x2F;slot&gt; avatar avatar 作用域插槽：准备1、作用域插槽是slot一个比较难理解的点，而且官方文档说的又有点不清晰2、这里，我们用一句话对其做一个总结，然后我们在后续的案例中来体会 父组件替换插槽的标签，但是内容由子组件来提供 3、我们先提一个需求 子组件中包括一组数据，比如：pLanguages: [&#39;JavaScript&#39;, &#39;Python&#39;, &#39;Swift&#39;, &#39;Go&#39;, &#39;C++&#39;] 需要在多个界面进行展示 某些界面是以水平方向一一展示的 某些界面是以列表形式展示的 某些界面直接展示一个数组 内容在子组件，希望父组件告诉我们如何展示，怎么办呢？ 利用slot作用域插槽就可以了 4、我们来看看子组件的定义： avatar 作用域插槽：使用1、在父组件使用我们的子组件时，从子组件中拿到数据 我们通过&lt;template slot-scope=&quot;slotProps&quot;&gt;获取到slotProps属性 在通过slotProps.data就可以获取到刚才我们传入的data了 avatar","categories":[{"name":"Vuejs快速学习系列","slug":"Vuejs快速学习系列","permalink":"https://jasondcq.github.io/categories/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://jasondcq.github.io/tags/Vuejs/"}],"author":"JasonD"},{"title":"Vuejs快速学习系列(二)  基础语法","slug":"Vuejs快速学习系列-二-基础语法","date":"2020-04-13T08:18:00.000Z","updated":"2020-04-13T13:40:56.100Z","comments":true,"path":"Vuejs快速学习系列-二-基础语法/","link":"","permalink":"https://jasondcq.github.io/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97-%E4%BA%8C-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"插值操作如何将data中的文本数据，插入到html中呢？可以通过Mustache语法(也就是双大括号),我们可以像下面这样来使用，并且数据是响应式的: avatar v-once在某些情况下，我们可能不希望界面随意的跟随改变,这个时候，我们就可以使用一个Vue的指令,v-once该指令后面不需要跟任何表达式,该指令表示元素和组件只渲染一次，不会随着数据的改变而改变,代码如下： avatar v-html当我们从服务器请求到的数据本身就是一个html代码，如果我们直接通过Mustache来输出，会将html代码也一起输出,但是我们可能希望的是按照html格式进行解析，并且显示对应的内容,这时候就可以使用v-html指令, 该指令后面往往会跟上一个string类型, 会将string的html解析出来并且进行渲染。 avatar v-text指令v-text作用和Mustache比较相似,都是用于将数据显示在界面中,v-text通常情况下，接受一个string类型. avatar v-pre指令v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法,比如下面的代码：第一个h2元素中的内容会被编译解析出来对应的内容；第二个h2元素中会直接显示 avatar 绑定属性前面我们学习的指令主要作用是将值插入到我们模板的内容当中，但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定，比如动态绑定a元素的href属性, 比如动态绑定img元素的src属性,这个时候，我们可以使用v-bind指令。 v-bind基础指令v-bind用于绑定一个或多个属性值，或者向另一个组件传递props值，在开发中，有哪些属性需要动态进行绑定呢？还是有很多的，比如图片的链接src、网站的链接href、动态绑定一些类、样式等等。通过Vue实例中的data绑定元素的src和href，代码如下： avatar v-bind语法糖指令v-bind有一个对应的语法糖，也就是简写方式,在开发中，我们通常会使用语法糖的形式，因为这样更加简洁,简写方式如下: avatar v-bind绑定class很多时候，我们希望动态的来切换class，比如:当数据为某个状态时，字体显示红色,当数据另一个状态时，字体显示黑色。绑定class有两种方式： 对象语法 数组语法 1、对象语法的含义是:class后面跟的是一个对象，有下面这些用法：用法一：直接通过{}绑定一个类例：html&lt;h2 :class=&quot;{&#39;active&#39;: isActive}&quot;&gt;Hello World&lt;/h2&gt; 用法二：也可以通过判断，传入多个值例：&lt;h2 :class=&quot;{&#39;active&#39;: isActive, &#39;line&#39;: isLine}&quot;&gt;Hello World&lt;/h2&gt; 用法三：和普通的类同时存在，并不冲突注：如果isActive和isLine都为true，那么会有title/active/line三个类例：&lt;h2 class=&quot;title&quot; :class=&quot;{&#39;active&#39;: isActive, &#39;line&#39;: isLine}&quot;&gt;Hello World&lt;/h2&gt; 用法四：如果过于复杂，可以放在一个methods或者computed中注：classes是一个计算属性例：&lt;h2 class=&quot;title&quot; :class=&quot;classes&quot;&gt;Hello World&lt;/h2&gt; 2、数组语法的含义是:class后面跟的是一个数组，有下面这些用法：用法一：直接通过{}绑定一个类例：&lt;h2 :class=&quot;[&#39;active&#39;]&quot;&gt;Hello World&lt;/h2&gt; 用法二：也可以传入多个值例：&lt;h2 :class=“[‘active’, &#39;line&#39;]&quot;&gt;Hello World&lt;/h2&gt; 用法三：和普通的类同时存在，并不冲突注：会有title/active/line三个类例：&lt;h2 class=&quot;title&quot; :class=“[‘active’, &#39;line&#39;]&quot;&gt;Hello World&lt;/h2&gt; v-bind绑定style我们可以利用v-bind:style来绑定一些CSS内联样式,在写CSS属性名的时候，比如font-size,我们可以使用驼峰式 (camelCase) fontSize,或短横线分隔 (kebab-case，记得用单引号括起来) ‘font-size’,绑定class有两种方式: 对象语法 1、代码:style=&quot;{color: currentColor, fontSize: fontSize + &#39;px&#39;}&quot;,style后面跟的是一个对象类型； 2、对象的key是CSS属性名称 3、对象的value是具体赋的值，值可以来自于data中的属性 数组语法 1、代码&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;,style后面跟的是一个数组类型多个值以，分割即可。 计算属性什么是计算属性？在模板中可以直接通过插值语法显示一些data中的数据，但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示，比如我们有firstName和lastName两个变量，我们需要显示完整的名称，但是如果多个地方都需要显示完整的名称，我们就需要写多个 ,这时候我们可以将上面的代码换成计算属性。计算属性是写在实例的computed选项中，如下： avatar avatar 计算属性中也可以进行一些更加复杂的操作，比如下面的例子： avatar 计算属性的setter和getter每个计算属性都包含一个getter和一个setter, 在上面的例子中，我们只是使用getter来读取,在某些情况下，你也可以提供一个setter方法（不常用）,在需要写setter的时候，代码如下： avatar 计算属性的缓存我们可能会考虑这样的一个问题, methods和computed看起来都可以实现我们的功能,那么为什么还要多一个计算属性这个东西呢？原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。 avatar avatar 事件监听在前端开发中，我们需要经常和用户交互，这个时候，我们就必须监听用户发生交互的时间，比如点击、拖拽、键盘事件等等。在Vue中如何监听事件呢？使用v-on指令 v-on基础我们用一个监听按钮的点击事件，来简单看看v-on的使用,下面的代码中，我们使用了v-on:click=&quot;counter++”,另外，我们可以将事件指向一个在methods中定义的函数 avatar avatar 指令v-on也有对应的语法糖v-on:click可以写成@click avatar v-on参数当通过methods中定义方法，以供@click调用时，需要注意参数问题,情况一如果该方法不需要额外参数，那么方法后的()可以不添加,但是注意如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去,情况二如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件: avatar avatar v-on修饰符在某些情况下，我们拿到event的目的可能是进行一些事件处理,Vue提供了修饰符来帮助我们方便的处理一些事件.stop - 调用 event.stopPropagation(),.prevent - 调用 event.preventDefault(), .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调,.native - 监听组件根元素的原生事件,.once - 只触发一次回调 avatar 条件判断v-if、v-else-if、v-else指令v-if、v-else-if、v-else这三个指令与JavaScript的条件语句if、else、else if类似,Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件,简单的案例演示: avatar avatar 原理v-if后面的条件为false时，对应的元素以及其子元素不会渲染,也就是根本没有不会有对应的标签出现在DOM中。 v-show指令v-show的用法和v-if非常相似，也用于决定一个元素是否渲染,v-if和v-show都可以决定一个元素是否渲染，那么开发中我们如何选择呢？v-if当条件为false时，压根不会有对应的元素在DOM中,v-show当条件为false时，仅仅是将元素的display属性设置为none而已。开发中如何选择呢？当需要在显示与隐藏之间切片很频繁时，使用v-show,当只有一次切换时，通过使用v-if avatar 循环遍历v-for遍历数组当我们有一组数据需要进行渲染时，我们就可以使用v-for来完成,v-for的语法类似于JavaScript中的for循环,格式如下：item in items的形式。如果在遍历的过程中不需要使用索引值-for=&quot;movie in movies&quot;依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie,如果在遍历的过程中，我们需要拿到元素在数组中的索引值呢？语法格式：v-for=(item, index) in items其中的index就代表了取出的item在原数组的索引值. avatar v-for遍历对象指令v-for可以用户遍历对象,比如某个对象中存储着你的个人信息，我们希望以列表的形式显示出来 avatar 组件的key属性官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性,key的作用主要是为了高效的更新虚拟DOM 检测数组更新因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新,Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新。push()、pop()、shift()、unshift()、splice()、sort()、reverse()； avatar v-model表单绑定v-model表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单,Vue中使用v-model指令来实现表单元素和数据的双向绑定。当我们在输入框输入内容时，因为input中的v-model绑定了message，所以会实时将输入的内容传递给message，message发生改变,当message发生改变时，因为上面我们使用Mustache语法，将message的值插入到DOM中，所以DOM会发生响应的改变,所以，通过v-model实现了双向的绑定 avatar 当然，我们也可以将v-model用于textarea元素 avatar v-model原理指令v-model其实是一个语法糖，它的背后本质上是包含两个操作。1.v-bind绑定一个value属性2.v-on指令给当前元素绑定input事件也就是说下面的代码：等同于下面的代码: avatar v-model：radio当存在多个单选框时 avatar v-model：checkbox复选框分为两种情况：单个勾选框和多个勾选框 单个勾选框1、v-model即为布尔值2、此时input的value并不影响v-model的值 多个复选框1、当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组2、当选中某一个时，就会将input的value添加到数组中 avatar avatar v-model：select和checkbox一样，select也分单选和多选两种情况 单选：只能选中一个值1、v-model绑定的是一个值2、当我们选中option中的一个时，会将它对应的value赋值到mySelect中 多选：可以选中多个值1、v-model绑定的是一个数组2、当选中多个值时，就会将选中的option对应的value添加到数组mySelects中 avatar avatar avatar","categories":[{"name":"Vuejs快速学习系列","slug":"Vuejs快速学习系列","permalink":"https://jasondcq.github.io/categories/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://jasondcq.github.io/tags/Vuejs/"}],"author":"JasonD"},{"title":"Vuejs快速学习系列(一)   Vue初体验与MVVM","slug":"认识Vuejs","date":"2020-04-11T08:46:00.000Z","updated":"2020-04-13T13:40:56.101Z","comments":true,"path":"认识Vuejs/","link":"","permalink":"https://jasondcq.github.io/%E8%AE%A4%E8%AF%86Vuejs/","excerpt":"","text":"简单认识VuejsVue读作/vju:/是一个渐进式的框架，这意味着你可以将Vue作为你应用的一部分嵌入其中，也可以使用Vue核心库及其生态系统，Core+Vue-router+Vuex实现各种各样的业务需求，带来更丰富的交互体验。 Vue的特点 1.解耦视图和数据；2.可复用组件；3.前端路由技术；4.状态管理；5.虚拟DOM； Hello Vuejs我们来编写我们的第一个Vue程序，体验一下Vue的响应式，截取代码如下： avatar 代码做了什么事情？我们来阅读JavaScript代码，会发现创建了一个Vue对象,在创建Vue对象的时候，传入了一些、options：{}，{}中包含了el属性：该属性决定了这个Vue对象挂载到哪一个元素上，很明显，我们这里是挂载到了id为app的元素上,{}中包含了data属性,该属性中通常会存储一些数据,这些数据可以是我们直接定义出来的，比如像上面这样;也可能是来自网络，从服务器加载的。当浏览器执行到10~13行代码显然出对应的HTML，执行第16行代码创建Vue实例，并且对原HTML进行解析和修改。 Vue列表显示现在，我们来展示一个更加复杂的数据：数据列表；当我们现在从服务器请求过来一个列表，希望展示到html中，截取代码如下： avatar avatar 在html代码中，使用v-for指令,是不是变得So Easy，我们再也不需要在JavaScript代码中完成DOM的拼接相关操作了。而且，它还是响应式的，当我们数组中的数据发生改变时，界面会自动改变。 Vue中的MVVM我们来看Vue的MVVM，图示如下： avatar View层： 视图层在我们前端开发中，通常就是DOM层主要的作用是给用户展示各种信息 Model层: 数据层数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据 VueModel层： 视图模型层视图模型层是View和Model沟通的桥梁一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data Vue的options我们在创建Vue实例的时候，传入了一个对象options，这个options中可以包含哪些选项呢？一般开发中主要掌握以下几点： el： 1、类型：string | HTMLElement 2、作用：决定之后Vue实例会管理哪一个DOM data： 1、类型：Object | Function （组件当中data必须是一个函数） 2、作用：Vue实例对应的数据对象 methods： 1、类型：{ [key: string]: Function } 2、作用：定义属于Vue的一些方法，可以在其他地方调用，也可以在指令中使用 Vue的生命周期生命周期流程图： avatar avatar","categories":[{"name":"Vuejs快速学习系列","slug":"Vuejs快速学习系列","permalink":"https://jasondcq.github.io/categories/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"https://jasondcq.github.io/tags/Vuejs/"}],"author":"JasonD"}],"categories":[{"name":"mac工具","slug":"mac工具","permalink":"https://jasondcq.github.io/categories/mac%E5%B7%A5%E5%85%B7/"},{"name":"Vuejs快速学习系列","slug":"Vuejs快速学习系列","permalink":"https://jasondcq.github.io/categories/Vuejs%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"mac工具","slug":"mac工具","permalink":"https://jasondcq.github.io/tags/mac%E5%B7%A5%E5%85%B7/"},{"name":"Vuejs","slug":"Vuejs","permalink":"https://jasondcq.github.io/tags/Vuejs/"}]}